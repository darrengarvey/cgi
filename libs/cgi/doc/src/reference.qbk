[/
 / Copyright (c) 2003-2008 Christopher M. Kohlhoff (chris at kohlhoff dot com)
 /
 / Copyright (c) 2009 Darren Garvey (darren dot garvey at gmail dot com)
 / -> Modification to work with the CGI library.
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[section:reference Reference]

[xinclude quickref.xml]


[section:cgi__common__stencil cgi__common::stencil]



  class stencil


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi__common__stencil.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.dictionary [*dictionary]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.parse_state [*parse_state]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.reload_option [*reload_option]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.section [*section]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.stencil_type [*stencil_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.strip [*strip]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi__common__stencil.add [*add]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.annotate_output [*annotate_output]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.expand [*expand]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.include [*include]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.native [*native]]]
    [Get the implementation type of the template. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.reset [*reset]]]
    [Clear the response buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.set [*set]]]
    [Set the varible `name` to `value` in the stencil. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.show [*show]]]
    [Show a section. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.state [*state]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.stencil [*stencil]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi__common__stencil.expanded [*expanded]]]
    []
  ]

  [
    [[link cgi.reference.cgi__common__stencil.impl [*impl]]]
    []
  ]

  [
    [[link cgi.reference.cgi__common__stencil.per_expand_data [*per_expand_data]]]
    []
  ]

  [
    [[link cgi.reference.cgi__common__stencil.tmpl [*tmpl]]]
    []
  ]

]


[section:add cgi__common::stencil::add]

[indexterm2 add..cgi__common::stencil] 

  dictionary add(
      section const & sec);



[endsect]



[section:annotate_output cgi__common::stencil::annotate_output]

[indexterm2 annotate_output..cgi__common::stencil] 

  self_type & annotate_output(
      bool annotate = true);



[endsect]



[section:base_type cgi__common::stencil::base_type]

[indexterm2 base_type..cgi__common::stencil] 

  typedef boost::cgi::common::response base_type;




[endsect]



[section:dictionary cgi__common::stencil::dictionary]

[indexterm2 dictionary..cgi__common::stencil] 

  typedef stencils::dictionary dictionary;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.stencils__dictionary.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__dictionary.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__dictionary.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__dictionary.add [*add]]]
    [Add a section into the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.dictionary [*dictionary]]]
    []
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.include [*include]]]
    [Include a file into the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.set [*set]]]
    [Set the varible `name` to `value` in the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.show [*show]]]
    [Show a section. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__dictionary.impl [*impl]]]
    []
  ]

]



[endsect]



[section:expand cgi__common::stencil::expand]

[indexterm2 expand..cgi__common::stencil] 

  bool expand(
      string_type const & template_name,
      enum reload_option reload_if_changed = cached,
      enum strip strip_option = strip_blank_lines);



[endsect]



[section:expanded cgi__common::stencil::expanded]

[indexterm2 expanded..cgi__common::stencil] 

  bool expanded;



[endsect]



[section:impl cgi__common::stencil::impl]

[indexterm2 impl..cgi__common::stencil] 

  boost::scoped_ptr< impl_type > impl;



[endsect]



[section:impl_type cgi__common::stencil::impl_type]

[indexterm2 impl_type..cgi__common::stencil] 

  typedef ctemplate::TemplateDictionary impl_type;




[endsect]


[section:include cgi__common::stencil::include]

[indexterm2 include..cgi__common::stencil] 

  dictionary ``[link cgi.reference.cgi__common__stencil.include.overload1 include]``(
      string_type const & section_name,
      string_type const & filename);

  dictionary ``[link cgi.reference.cgi__common__stencil.include.overload2 include]``(
      section const & sec);


[section:overload1 cgi__common::stencil::include (1 of 2 overloads)]



  dictionary include(
      string_type const & section_name,
      string_type const & filename);



[endsect]



[section:overload2 cgi__common::stencil::include (2 of 2 overloads)]



  dictionary include(
      section const & sec);



[endsect]


[endsect]


[section:native cgi__common::stencil::native]

[indexterm2 native..cgi__common::stencil] Get the implementation type of the template. 

  impl_type & native();



[endsect]



[section:parse_state cgi__common::stencil::parse_state]

[indexterm2 parse_state..cgi__common::stencil] 

  enum parse_state

[heading Values]
[variablelist

  [
    [unused]
    []
  ]

  [
    [empty]
    []
  ]

  [
    [error]
    []
  ]

  [
    [ready]
    []
  ]

  [
    [should_reload]
    []
  ]

]



[endsect]



[section:per_expand_data cgi__common::stencil::per_expand_data]

[indexterm2 per_expand_data..cgi__common::stencil] 

  ctemplate::PerExpandData per_expand_data;



[endsect]



[section:reload_option cgi__common::stencil::reload_option]

[indexterm2 reload_option..cgi__common::stencil] 

  enum reload_option

[heading Values]
[variablelist

  [
    [cached]
    []
  ]

  [
    [reload]
    []
  ]

  [
    [reload_all]
    []
  ]

]



[endsect]



[section:reset cgi__common::stencil::reset]

[indexterm2 reset..cgi__common::stencil] Clear the response buffer. 

  void reset(
      impl_type * use_dict = NULL);



[endsect]



[section:section cgi__common::stencil::section]

[indexterm2 section..cgi__common::stencil] 

  typedef stencils::section section;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.stencils__section.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__section.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__section.section [*section]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__section.filename [*filename]]]
    []
  ]

  [
    [[link cgi.reference.stencils__section.name [*name]]]
    []
  ]

]



[endsect]



[section:self_type cgi__common::stencil::self_type]

[indexterm2 self_type..cgi__common::stencil] 

  typedef stencil self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.cgi__common__stencil.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.dictionary [*dictionary]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.parse_state [*parse_state]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.reload_option [*reload_option]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.section [*section]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.stencil_type [*stencil_type]]]
    []
  
  ]

  [

    [[link cgi.reference.cgi__common__stencil.strip [*strip]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi__common__stencil.add [*add]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.annotate_output [*annotate_output]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.expand [*expand]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.include [*include]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.native [*native]]]
    [Get the implementation type of the template. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.reset [*reset]]]
    [Clear the response buffer. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.set [*set]]]
    [Set the varible `name` to `value` in the stencil. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.show [*show]]]
    [Show a section. ]
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.state [*state]]]
    []
  ]
  
  [
    [[link cgi.reference.cgi__common__stencil.stencil [*stencil]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.cgi__common__stencil.expanded [*expanded]]]
    []
  ]

  [
    [[link cgi.reference.cgi__common__stencil.impl [*impl]]]
    []
  ]

  [
    [[link cgi.reference.cgi__common__stencil.per_expand_data [*per_expand_data]]]
    []
  ]

  [
    [[link cgi.reference.cgi__common__stencil.tmpl [*tmpl]]]
    []
  ]

]



[endsect]


[section:set cgi__common::stencil::set]

[indexterm2 set..cgi__common::stencil] Set the varible `name` to `value` in the stencil. 

  template<
      typename T >
  self_type & ``[link cgi.reference.cgi__common__stencil.set.overload1 set]``(
      string_type const & name,
      T value);

  template<
      typename T >
  self_type & ``[link cgi.reference.cgi__common__stencil.set.overload2 set]``(
      string_type const & name,
      T value,
      section const & sec);

  template<>
  stencil & ``[link cgi.reference.cgi__common__stencil.set.overload3 set]``(
      string_type const & name,
      string_type const & value);

  template<>
  stencil & ``[link cgi.reference.cgi__common__stencil.set.overload4 set]``(
      string_type const & name,
      string_type const & value,
      section const & sec);


[section:overload1 cgi__common::stencil::set (1 of 4 overloads)]

Set the varible `name` to `value` in the stencil. 

  template<
      typename T >
  self_type & set(
      string_type const & name,
      T value);



[heading Parameters]
    

[variablelist
  
[[name][The name of the variable. Use {{name}} in the stencil. ]]

[[value][The value, can be any type that is supported by boost::lexical\_cast. See the docs for lexical\_cast: http://www.boost.org/libs/lexical\_cast]]

]



[endsect]



[section:overload2 cgi__common::stencil::set (2 of 4 overloads)]

Set a variable and show a section in one go. 

  template<
      typename T >
  self_type & set(
      string_type const & name,
      T value,
      section const & sec);



[endsect]



[section:overload3 cgi__common::stencil::set (3 of 4 overloads)]

Set the varible `name` to `value` in the stencil. 

  template<>
  stencil & set(
      string_type const & name,
      string_type const & value);



[endsect]



[section:overload4 cgi__common::stencil::set (4 of 4 overloads)]

Set a variable and show a section in one go. 

  template<>
  stencil & set(
      string_type const & name,
      string_type const & value,
      section const & sec);



[endsect]


[endsect]


[section:show cgi__common::stencil::show]

[indexterm2 show..cgi__common::stencil] Show a section. 

  self_type & show(
      section const & sec);



[endsect]



[section:state cgi__common::stencil::state]

[indexterm2 state..cgi__common::stencil] 

  parse_state state();



[endsect]


[section:stencil cgi__common::stencil::stencil]

[indexterm2 stencil..cgi__common::stencil] 

  ``[link cgi.reference.cgi__common__stencil.stencil.overload1 stencil]``(
      impl_type * parent_dict);

  ``[link cgi.reference.cgi__common__stencil.stencil.overload2 stencil]``(
      string_type const & root_dir = "");


[section:overload1 cgi__common::stencil::stencil (1 of 2 overloads)]



  stencil(
      impl_type * parent_dict);



[endsect]



[section:overload2 cgi__common::stencil::stencil (2 of 2 overloads)]



  stencil(
      string_type const & root_dir = "");



[endsect]


[endsect]


[section:stencil_type cgi__common::stencil::stencil_type]

[indexterm2 stencil_type..cgi__common::stencil] 

  typedef ctemplate::Template stencil_type;




[endsect]



[section:strip cgi__common::stencil::strip]

[indexterm2 strip..cgi__common::stencil] 

  enum strip

[heading Values]
[variablelist

  [
    [do_not_strip]
    []
  ]

  [
    [strip_blank_lines]
    []
  ]

  [
    [strip_whitespace]
    []
  ]

]



[endsect]



[section:tmpl cgi__common::stencil::tmpl]

[indexterm2 tmpl..cgi__common::stencil] 

  stencil_type * tmpl;



[endsect]



[endsect]

[section:is_error_code_enum_lt____BOOST_CGI_NAMESPACE__common__error__cgi_errors__gt_ boost::system::is_error_code_enum< ::BOOST_CGI_NAMESPACE::common::error::cgi_errors >]



  template<>
  struct boost::system::is_error_code_enum< ::BOOST_CGI_NAMESPACE::common::error::cgi_errors >


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.is_error_code_enum_lt____BOOST_CGI_NAMESPACE__common__error__cgi_errors__gt_.BOOST_STATIC_CONSTANT [*BOOST_STATIC_CONSTANT]]]
    []
  ]
  
]


[section:BOOST_STATIC_CONSTANT boost::system::is_error_code_enum< ::BOOST_CGI_NAMESPACE::common::error::cgi_errors >::BOOST_STATIC_CONSTANT]

[indexterm2 BOOST_STATIC_CONSTANT..boost::system::is_error_code_enum< ::BOOST_CGI_NAMESPACE::common::error::cgi_errors >] 

  BOOST_STATIC_CONSTANT(
      bool ,
      value  = true);



[endsect]



[endsect]


[section: cgi__service]



  typedef cgi_service service;




[endsect]


[section:common__basic_client common::basic_client]

A client. 

  template<
      typename Connection ,
      typename Protocol >
  class basic_client


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.header_buffer_type [*header_buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.io_service_type [*io_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.role_type [*role_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.construct [*construct]]]
    [Construct the client by claiming a request id. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.handle_write [*handle_write]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.keep_connection [*keep_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.prepare_buffer [*prepare_buffer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read data into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.status [*status]]]
    [Get the status of the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.header_ [*header_]]]
    [Buffer used to check the header of each packet. ]
  ]

  [
    [[link cgi.reference.common__basic_client.keep_connection_ [*keep_connection_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.outbuf_ [*outbuf_]]]
    [Output buffer. ]
  ]

  [
    [[link cgi.reference.common__basic_client.request_id_ [*request_id_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.role_ [*role_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.status_ [*status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.total_sent_bytes_ [*total_sent_bytes_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.total_sent_packets_ [*total_sent_packets_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 


[section:async_read_some common::basic_client::async_read_some]

[indexterm2 async_read_some..common::basic_client] Asynchronously read some data from the client. 

  template<
      typename MutableBufferSequence ,
      typename Handler >
  void async_read_some(
      const MutableBufferSequence & buf,
      Handler handler);



[endsect]


[section:async_write_some common::basic_client::async_write_some]

[indexterm2 async_write_some..common::basic_client] Asynchronously write some data to the client. 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void ``[link cgi.reference.common__basic_client.async_write_some.overload1 async_write_some]``(
      const ConstBufferSequence & buf,
      Handler handler);

  template<>
  void ``[link cgi.reference.common__basic_client.async_write_some.overload2 async_write_some]``(
      const ConstBufferSequence & buf,
      Handler handler);


[section:overload1 common::basic_client::async_write_some (1 of 2 overloads)]

Asynchronously write some data to the client. 

  template<
      typename ConstBufferSequence ,
      typename Handler >
  void async_write_some(
      const ConstBufferSequence & buf,
      Handler handler);



[endsect]



[section:overload2 common::basic_client::async_write_some (2 of 2 overloads)]



  template<>
  void async_write_some(
      const ConstBufferSequence & buf,
      Handler handler);



[endsect]


[endsect]

[section:basic_client common::basic_client::basic_client]

[indexterm2 basic_client..common::basic_client] 

  ``[link cgi.reference.common__basic_client.basic_client.overload1 basic_client]``();

  ``[link cgi.reference.common__basic_client.basic_client.overload2 basic_client]``(
      io_service & ios);

  template<>
  ``[link cgi.reference.common__basic_client.basic_client.overload3 basic_client]``();

  template<>
  ``[link cgi.reference.common__basic_client.basic_client.overload4 basic_client]``(
      io_service_type & ios);


[section:overload1 common::basic_client::basic_client (1 of 4 overloads)]



  basic_client();



[endsect]



[section:overload2 common::basic_client::basic_client (2 of 4 overloads)]



  basic_client(
      io_service & ios);



[endsect]



[section:overload3 common::basic_client::basic_client (3 of 4 overloads)]



  template<>
  basic_client();



[endsect]



[section:overload4 common::basic_client::basic_client (4 of 4 overloads)]



  template<>
  basic_client(
      io_service_type & ios);



[endsect]


[endsect]


[section:bytes_left common::basic_client::bytes_left]

[indexterm2 bytes_left..common::basic_client] 

  std::size_t & bytes_left();



[endsect]



[section:bytes_left_ common::basic_client::bytes_left_]

[indexterm2 bytes_left_..common::basic_client] 

  std::size_t bytes_left_;



[endsect]


[section:close common::basic_client::close]

[indexterm2 close..common::basic_client] 

  boost::system::error_code ``[link cgi.reference.common__basic_client.close.overload1 close]``(
      boost::uint64_t app_status,
      boost::system::error_code & ec);

  void ``[link cgi.reference.common__basic_client.close.overload2 close]``(
      boost::uint64_t app_status = 0);

  template<>
  boost::system::error_code ``[link cgi.reference.common__basic_client.close.overload3 close]``(
      boost::uint64_t app_status,
      boost::system::error_code & ec);


[section:overload1 common::basic_client::close (1 of 3 overloads)]



  boost::system::error_code close(
      boost::uint64_t app_status,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_client::close (2 of 3 overloads)]



  void close(
      boost::uint64_t app_status = 0);



[endsect]



[section:overload3 common::basic_client::close (3 of 3 overloads)]



  template<>
  boost::system::error_code close(
      boost::uint64_t app_status,
      boost::system::error_code & ec);


Closing a FastCGI means sending an END\_REQUEST header to the HTTP server and potentially closing the connection.

Note that in general the HTTP server is responsible for the lifetime of the connection, but can hand that control over to the library (eg. if the server is set up to recycle connections after N requests). 


[endsect]


[endsect]


[section:connection common::basic_client::connection]

[indexterm2 connection..common::basic_client] Get a shared_ptr of the connection associated with the client. 

  connection_ptr & connection();



[endsect]



[section:connection_ptr common::basic_client::connection_ptr]

[indexterm2 connection_ptr..common::basic_client] 

  typedef connection_type::pointer connection_ptr;




[endsect]



[section:connection_type common::basic_client::connection_type]

[indexterm2 connection_type..common::basic_client] 

  typedef Connection connection_type;




[endsect]



[section:construct common::basic_client::construct]

[indexterm2 construct..common::basic_client] Construct the client by claiming a request id. 

  template<
      typename RequestImpl >
  boost::system::error_code construct(
      RequestImpl & req,
      boost::system::error_code & ec);


Before loading a request, it will usually not have a request id. This function reads headers (and corresponding bodies if necessary) until a BEGIN\_REQUEST record is found. The calling request then claims and serves that request. 


[endsect]



[section:handle_write common::basic_client::handle_write]

[indexterm2 handle_write..common::basic_client] 

  template<>
  void handle_write(
      std::size_t bytes_transferred,
      boost::system::error_code & ec);



[endsect]



[section:header_ common::basic_client::header_]

[indexterm2 header_..common::basic_client] Buffer used to check the header of each packet. 

  fcgi::spec::header header_;



[endsect]



[section:header_buffer_type common::basic_client::header_buffer_type]

[indexterm2 header_buffer_type..common::basic_client] 

  typedef boost::array< unsigned char, 8 > header_buffer_type;




[endsect]



[section:io_service_type common::basic_client::io_service_type]

[indexterm2 io_service_type..common::basic_client] 

  typedef ::BOOST_CGI_NAMESPACE::common::io_service io_service_type;




[endsect]



[section:is_open common::basic_client::is_open]

[indexterm2 is_open..common::basic_client] 

  bool is_open();



[endsect]



[section:keep_connection common::basic_client::keep_connection]

[indexterm2 keep_connection..common::basic_client] 

  bool keep_connection() const;



[endsect]



[section:keep_connection_ common::basic_client::keep_connection_]

[indexterm2 keep_connection_..common::basic_client] 

  bool keep_connection_;



[endsect]



[section:map_type common::basic_client::map_type]

[indexterm2 map_type..common::basic_client] 

  typedef ::BOOST_CGI_NAMESPACE::common::map map_type;




[endsect]



[section:mutable_buffers_type common::basic_client::mutable_buffers_type]

[indexterm2 mutable_buffers_type..common::basic_client] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:outbuf_ common::basic_client::outbuf_]

[indexterm2 outbuf_..common::basic_client] Output buffer. 

  std::vector< boost::asio::const_buffer > outbuf_;



[endsect]



[section:prepare_buffer common::basic_client::prepare_buffer]

[indexterm2 prepare_buffer..common::basic_client] 

  template<>
  void prepare_buffer(
      const ConstBufferSequence & buf);



[endsect]



[section:protocol_type common::basic_client::protocol_type]

[indexterm2 protocol_type..common::basic_client] 

  typedef Protocol protocol_type;




[endsect]



[section:read_some common::basic_client::read_some]

[indexterm2 read_some..common::basic_client] Read data into the supplied buffer. 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);


Reads some data that, correctly checking and stripping FastCGI headers.

Returns the number of bytes read and sets `ec` such that `ec` evaluates to `true` iff an error occured during the read operation.

Notable errors:
* `fcgierror::data_for_another_request`

* `fcgierror::connection_locked`


These must be dealt with by user code if they choose to read through the client (reading through the request is recommended). 


[endsect]



[section:request_id common::basic_client::request_id]

[indexterm2 request_id..common::basic_client] 

  boost::uint16_t const & request_id() const;



[endsect]



[section:request_id_ common::basic_client::request_id_]

[indexterm2 request_id_..common::basic_client] 

  boost::uint16_t request_id_;



[endsect]



[section:role_ common::basic_client::role_]

[indexterm2 role_..common::basic_client] 

  role_type role_;



[endsect]



[section:role_type common::basic_client::role_type]

[indexterm2 role_type..common::basic_client] 

  typedef detail::protocol_traits< Protocol >::role_type role_type;




[endsect]


[section:set_connection common::basic_client::set_connection]

[indexterm2 set_connection..common::basic_client] Associate a connection with this client. 

  bool ``[link cgi.reference.common__basic_client.set_connection.overload1 set_connection]``(
      connection_type * conn);

  bool ``[link cgi.reference.common__basic_client.set_connection.overload2 set_connection]``(
      const typename connection_type::pointer & conn);


[section:overload1 common::basic_client::set_connection (1 of 2 overloads)]

Associate a connection with this client. 

  bool set_connection(
      connection_type * conn);


Note: the connection must have been created using the new operator 


[endsect]



[section:overload2 common::basic_client::set_connection (2 of 2 overloads)]

Associate a connection with this client. 

  bool set_connection(
      const typename connection_type::pointer & conn);


Note: the connection must have been created using the new operator 


[endsect]


[endsect]

[section:status common::basic_client::status]

[indexterm2 status..common::basic_client] Get the status of the client. 

  const client_status & ``[link cgi.reference.common__basic_client.status.overload1 status]``() const;

  void ``[link cgi.reference.common__basic_client.status.overload2 status]``(
      client_status status);


[section:overload1 common::basic_client::status (1 of 2 overloads)]

Get the status of the client. 

  const client_status & status() const;



[endsect]



[section:overload2 common::basic_client::status (2 of 2 overloads)]

Set the status of the client. 

  void status(
      client_status status);



[endsect]


[endsect]


[section:status_ common::basic_client::status_]

[indexterm2 status_..common::basic_client] 

  client_status status_;



[endsect]



[section:total_sent_bytes_ common::basic_client::total_sent_bytes_]

[indexterm2 total_sent_bytes_..common::basic_client] 

  boost::uint64_t total_sent_bytes_;



[endsect]



[section:total_sent_packets_ common::basic_client::total_sent_packets_]

[indexterm2 total_sent_packets_..common::basic_client] 

  boost::uint64_t total_sent_packets_;



[endsect]


[section:write_some common::basic_client::write_some]

[indexterm2 write_some..common::basic_client] Write some data to the client. 

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_client.write_some.overload1 write_some]``(
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);

  template<>
  std::size_t ``[link cgi.reference.common__basic_client.write_some.overload2 write_some]``(
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);


[section:overload1 common::basic_client::write_some (1 of 2 overloads)]

Write some data to the client. 

  template<
      typename ConstBufferSequence >
  std::size_t write_some(
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::basic_client::write_some (2 of 2 overloads)]



  template<>
  std::size_t write_some(
      const ConstBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]


[endsect]


[endsect]

[section:common__basic_cookie common::basic_cookie]

A `basic_cookie<>` object that can be (out-) streamed. 

  template<
      typename CharT >
  struct basic_cookie


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_cookie.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.basic_cookie [*basic_cookie]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.c_str [*c_str]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.empty [*empty]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_const_char_type_* [*operator const char_type *]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_std__basic_string_lt__T__gt_ [*operator std::basic_string< T >]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_string_type [*operator string_type]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_string_type_const_& [*operator string_type const &]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.to_string [*to_string]]]
    [TODO: Create a cookie from a const char*. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.domain [*domain]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.expires [*expires]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.http_only [*http_only]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.name [*name]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.path [*path]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.secure [*secure]]]
    [`true` iff the cookie is only used for secure connections. ]
  ]

  [
    [[link cgi.reference.common__basic_cookie.value [*value]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.operator_lt__lt_ [*operator<<]]]
    []
  ]
  
]

Either set the parameters in the constructor, or set them directly. Note: If you want to set the parameters individually, remember that each parameter must NOT have a trailing semi-colon!

TODO
* Data should be URL-encoded, or maybe provide an overload for url_decode that takes an HttpCookie?

* Add from_string() ? 


[section:basic_cookie common::basic_cookie::basic_cookie]

[indexterm2 basic_cookie..common::basic_cookie] 

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload1 basic_cookie]``();

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload2 basic_cookie]``(
      const char * _name);

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload3 basic_cookie]``(
      const string_type & _name);

  ``[link cgi.reference.common__basic_cookie.basic_cookie.overload4 basic_cookie]``(
      const string_type & _name,
      const string_type & _val,
      const string_type & _expires = "",
      const string_type & _path = "/",
      const string_type & _domain = "",
      bool _secure = false,
      bool HttpOnly = false);


[section:overload1 common::basic_cookie::basic_cookie (1 of 4 overloads)]



  basic_cookie();



[endsect]



[section:overload2 common::basic_cookie::basic_cookie (2 of 4 overloads)]



  basic_cookie(
      const char * _name);



[endsect]



[section:overload3 common::basic_cookie::basic_cookie (3 of 4 overloads)]

Create a cookie for deleting the cookie named `_name`. 

  basic_cookie(
      const string_type & _name);



[endsect]



[section:overload4 common::basic_cookie::basic_cookie (4 of 4 overloads)]

Create a cookie. 

  basic_cookie(
      const string_type & _name,
      const string_type & _val,
      const string_type & _expires = "",
      const string_type & _path = "/",
      const string_type & _domain = "",
      bool _secure = false,
      bool HttpOnly = false);



[endsect]


[endsect]


[section:c_str common::basic_cookie::c_str]

[indexterm2 c_str..common::basic_cookie] 

  const char_type * c_str() const;



[endsect]



[section:char_type common::basic_cookie::char_type]

[indexterm2 char_type..common::basic_cookie] 

  typedef CharT char_type;




[endsect]



[section:domain common::basic_cookie::domain]

[indexterm2 domain..common::basic_cookie] 

  string_type domain;



[endsect]



[section:empty common::basic_cookie::empty]

[indexterm2 empty..common::basic_cookie] 

  bool empty() const;



[endsect]



[section:expires common::basic_cookie::expires]

[indexterm2 expires..common::basic_cookie] 

  string_type expires;



[endsect]



[section:http_only common::basic_cookie::http_only]

[indexterm2 http_only..common::basic_cookie] 

  bool http_only;



[endsect]



[section:name common::basic_cookie::name]

[indexterm2 name..common::basic_cookie] 

  string_type name;



[endsect]



[section:operator_const_char_type_* common::basic_cookie::operator const char_type *]

[indexterm2 operator const char_type *..common::basic_cookie] 

  operator const char_type *() const;



[endsect]



[section:operator_std__basic_string_lt__T__gt_ common::basic_cookie::operator std::basic_string< T >]

[indexterm2 operator std::basic_string< T >..common::basic_cookie] 

  template<
      typename T >
  operator std::basic_string< T >();



[endsect]



[section:operator_string_type common::basic_cookie::operator string_type]

[indexterm2 operator string_type..common::basic_cookie] 

  operator string_type() const;



[endsect]



[section:operator_string_type_const_& common::basic_cookie::operator string_type const &]

[indexterm2 operator string_type const &..common::basic_cookie] 

  operator string_type const &() const;



[endsect]



[section:operator_lt__lt_ common::basic_cookie::operator<<]

[indexterm2 operator<<..common::basic_cookie] 

  template<
      typename T >
  friend std::ostream & operator<<(
      std::ostream & os,
      basic_cookie< T > const & ck);



[endsect]



[section:path common::basic_cookie::path]

[indexterm2 path..common::basic_cookie] 

  string_type path;



[endsect]



[section:secure common::basic_cookie::secure]

[indexterm2 secure..common::basic_cookie] `true` iff the cookie is only used for secure connections. 

  bool secure;



[endsect]



[section:self_type common::basic_cookie::self_type]

[indexterm2 self_type..common::basic_cookie] 

  typedef basic_cookie< CharT > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_cookie.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_cookie.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.basic_cookie [*basic_cookie]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.c_str [*c_str]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.empty [*empty]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_const_char_type_* [*operator const char_type *]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_std__basic_string_lt__T__gt_ [*operator std::basic_string< T >]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_string_type [*operator string_type]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.operator_string_type_const_& [*operator string_type const &]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_cookie.to_string [*to_string]]]
    [TODO: Create a cookie from a const char*. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.domain [*domain]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.expires [*expires]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.http_only [*http_only]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.name [*name]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.path [*path]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_cookie.secure [*secure]]]
    [`true` iff the cookie is only used for secure connections. ]
  ]

  [
    [[link cgi.reference.common__basic_cookie.value [*value]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_cookie.operator_lt__lt_ [*operator<<]]]
    []
  ]
  
]

Either set the parameters in the constructor, or set them directly. Note: If you want to set the parameters individually, remember that each parameter must NOT have a trailing semi-colon!

TODO
* Data should be URL-encoded, or maybe provide an overload for url_decode that takes an HttpCookie?

* Add from_string() ? 




[endsect]



[section:string_type common::basic_cookie::string_type]

[indexterm2 string_type..common::basic_cookie] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[section:to_string common::basic_cookie::to_string]

[indexterm2 to_string..common::basic_cookie] TODO: Create a cookie from a const char*. 

  string_type to_string() const;


Rules at: http://wp.netscape.com/newsref/std/cookie\_spec.html Make a string out of the cookie. 


[endsect]



[section:value common::basic_cookie::value]

[indexterm2 value..common::basic_cookie] 

  string_type value;



[endsect]



[endsect]

[section:common__basic_header common::basic_header]



  template<
      typename ``[link cgi.reference.CharT CharT]``>
  struct basic_header


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_header.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_header.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_header.basic_header [*basic_header]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_header.operator_string_type [*operator string_type]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_header.content [*content]]]
    []
  ]

]

[section:basic_header common::basic_header::basic_header]

[indexterm2 basic_header..common::basic_header] 

  ``[link cgi.reference.common__basic_header.basic_header.overload1 basic_header]``();

  ``[link cgi.reference.common__basic_header.basic_header.overload2 basic_header]``(
      const string_type & _content);

  ``[link cgi.reference.common__basic_header.basic_header.overload3 basic_header]``(
      const string_type & name,
      const string_type & val);


[section:overload1 common::basic_header::basic_header (1 of 3 overloads)]



  basic_header();



[endsect]



[section:overload2 common::basic_header::basic_header (2 of 3 overloads)]



  basic_header(
      const string_type & _content);



[endsect]



[section:overload3 common::basic_header::basic_header (3 of 3 overloads)]



  basic_header(
      const string_type & name,
      const string_type & val);



[endsect]


[endsect]


[section:char_type common::basic_header::char_type]

[indexterm2 char_type..common::basic_header] 

  typedef CharT char_type;




[endsect]



[section:content common::basic_header::content]

[indexterm2 content..common::basic_header] 

  string_type content;



[endsect]



[section:operator_string_type common::basic_header::operator string_type]

[indexterm2 operator string_type..common::basic_header] 

  operator string_type();



[endsect]



[section:string_type common::basic_header::string_type]

[indexterm2 string_type..common::basic_header] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[endsect]

[section:common__basic_protocol_service common::basic_protocol_service]

Basic Protocol Service. 

  template<
      typename ``[link cgi.reference.Protocol Protocol]``,
      typename ``[link cgi.reference.IoServiceProvider IoServiceProvider]``>
  class basic_protocol_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 

[section:basic_protocol_service common::basic_protocol_service::basic_protocol_service]

[indexterm2 basic_protocol_service..common::basic_protocol_service] 

  ``[link cgi.reference.common__basic_protocol_service.basic_protocol_service.overload1 basic_protocol_service]``(
      int pool_size_hint = 1);

  ``[link cgi.reference.common__basic_protocol_service.basic_protocol_service.overload2 basic_protocol_service]``(
      boost::asio::io_service & ios);


[section:overload1 common::basic_protocol_service::basic_protocol_service (1 of 2 overloads)]



  basic_protocol_service(
      int pool_size_hint = 1);



[endsect]



[section:overload2 common::basic_protocol_service::basic_protocol_service (2 of 2 overloads)]



  basic_protocol_service(
      boost::asio::io_service & ios);



[endsect]


[endsect]


[section:dispatch common::basic_protocol_service::dispatch]

[indexterm2 dispatch..common::basic_protocol_service] Dispatch a handler through an available io_service. 

  template<
      typename Handler >
  void dispatch(
      Handler handler);



[endsect]



[section:io_service common::basic_protocol_service::io_service]

[indexterm2 io_service..common::basic_protocol_service] Return an available io_service from the IoServiceProvider. 

  ::BOOST_CGI_NAMESPACE::common::io_service & io_service();


The order in which the underlying io\_services are returned is determined by what policy the IoServiceProvider uses. 


[endsect]



[section:ios_provider_type common::basic_protocol_service::ios_provider_type]

[indexterm2 ios_provider_type..common::basic_protocol_service] 

  typedef IoServiceProvider ios_provider_type;




[endsect]



[section:is_cgi common::basic_protocol_service::is_cgi]

[indexterm2 is_cgi..common::basic_protocol_service] 

  bool is_cgi();



[endsect]



[section:post common::basic_protocol_service::post]

[indexterm2 post..common::basic_protocol_service] Post the handler through an available io_service. 

  template<
      typename Handler >
  void post(
      Handler handler);



[endsect]



[section:protocol_type common::basic_protocol_service::protocol_type]

[indexterm2 protocol_type..common::basic_protocol_service] 

  typedef Protocol protocol_type;




[endsect]



[section:queue_type common::basic_protocol_service::queue_type]

[indexterm2 queue_type..common::basic_protocol_service] 

  typedef std::queue< request_ptr > queue_type;




[endsect]



[section:request_ptr common::basic_protocol_service::request_ptr]

[indexterm2 request_ptr..common::basic_protocol_service] 

  typedef boost::shared_ptr< request_type > request_ptr;




[endsect]



[section:request_type common::basic_protocol_service::request_type]

[indexterm2 request_type..common::basic_protocol_service] 

  typedef traits::request_type request_type;




[endsect]



[section:reset common::basic_protocol_service::reset]

[indexterm2 reset..common::basic_protocol_service] Reset all the io_services contained by this service. 

  void reset();


This deletes the request queue(s), aborts all running requests and then calls reset() on each of the io\_services held by ios\_provider\_. There is no guarantee that requests will terminate immediately. 


[endsect]



[section:run common::basic_protocol_service::run]

[indexterm2 run..common::basic_protocol_service] Run all the io_services contained by this service. 

  void run();


This is equivalent to calling run() on each of the io\_services held by ios\_provider\_ 


[endsect]



[section:set_type common::basic_protocol_service::set_type]

[indexterm2 set_type..common::basic_protocol_service] 

  typedef std::set< request_ptr > set_type;




[endsect]



[section:stop common::basic_protocol_service::stop]

[indexterm2 stop..common::basic_protocol_service] Stop all the io_services contained by this service. 

  void stop();


This is equivalent to calling stop() on each of the io\_services held by ios\_provider\_ 


[endsect]



[section:traits common::basic_protocol_service::traits]

[indexterm2 traits..common::basic_protocol_service] 

  typedef detail::protocol_traits< Protocol >::type traits;




[endsect]



[section:_basic_protocol_service common::basic_protocol_service::~basic_protocol_service]

[indexterm2 ~basic_protocol_service..common::basic_protocol_service] 

  ~basic_protocol_service();



[endsect]



[endsect]

[section:common__basic_request common::basic_request]

The basic_request class, primary entry point to the library. 

  template<
      typename ``[link cgi.reference.Protocol Protocol]``>
  class basic_request


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.service_type [*service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request.abort [*abort]]]
    [Abort a request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.auth_type [*auth_type]]]
    [Set the output for the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.basic_request [*basic_request]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.charset [*charset]]]
    [Get the charset from the CONTENT_TYPE header. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.clear [*clear]]]
    [Clear the data for the request, for reusing this object. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.client [*client]]]
    [Get the client connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.close [*close]]]
    [Asynchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.content_length [*content_length]]]
    [Get the content length as a long. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.content_type [*content_type]]]
    [The content type of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.gateway_interface [*gateway_interface]]]
    [The protocol used by the server to communicate to the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.hash [*hash]]]
    [Get a hashed interpretation of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.http_cookie [*http_cookie]]]
    [The cookies sent by the user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.http_from [*http_from]]]
    [The email of the user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.id [*id]]]
    [The id of this request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.is_open [*is_open]]]
    [Check if the request is still open (ie. not aborted or closed). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.method [*method]]]
    [The method of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.path_info [*path_info]]]
    [Additional information, appendended to the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.path_translated [*path_translated]]]
    [The translated version of the path info. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.post_buffer [*post_buffer]]]
    [Get the buffer containing the POST data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.query_string [*query_string]]]
    [The query string for the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.read_some [*read_some]]]
    [Read some data into the request, parsing if necessary. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.referer [*referer]]]
    [Get the web page the user came from. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.reject [*reject]]]
    [Reject the request with a '500 Internal Server Error' error. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_addr [*remote_addr]]]
    [The host address of the remote user. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_host [*remote_host]]]
    [The host name of the remote user's machine. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_ident [*remote_ident]]]
    [The user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_user [*remote_user]]]
    [The userid of the person accessing the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.request_method [*request_method]]]
    [The method of the request (long-hand of `method()`). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.request_uri [*request_uri]]]
    [Get the URI of the request (long-hand of `uri()`). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.role [*role]]]
    [The role that the request is playing. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_name [*script_name]]]
    [The name of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_uri [*script_uri]]]
    [The full URI of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_url [*script_url]]]
    [The URL of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_name [*server_name]]]
    [Get the name of the server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_port [*server_port]]]
    [Get the port the calling server is listening on. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_protocol [*server_protocol]]]
    [Get the protocol being used by the calling server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_software [*server_software]]]
    [Get a string identifying the calling server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.status [*status]]]
    [Get / Set the status of a request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.uri [*uri]]]
    [Get the URI of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request._basic_request [*~basic_request]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request.cookies [*cookies]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.env [*env]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.form [*form]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.get [*get]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.post [*post]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.uploads [*uploads]]]
    []
  ]

]

Note: By default, synchronous protocols (ie. cgi) auto-load AND parse STDIN,whereas async protocols don't.

Note: The alternative functions which take a boost::system::error\_code are the non-throwing versions. Instead of a boost::system::system\_error being thrown in case of an error, the passed error\_code will be set to the value of the error, s.t. if (error) evaluates to true.`

Note: This class isn't thread safe: carrying around a mutex-per-request seems prohibitively expensive. There could be functions which take a mutex as an argument and lock it. (Async calls could get messy if you need a protected request object). 


[section:abort common::basic_request::abort]

[indexterm2 abort..common::basic_request] Abort a request. 

  void abort();



[endsect]



[section:auth_type common::basic_request::auth_type]

[indexterm2 auth_type..common::basic_request] Set the output for the request. 

  string_type & auth_type();


Not Implemented Yet ******************

Set the output sink as `stdout\_`, `stderr\_`, or `stdout\_ | stderr\_` 


[endsect]


[section:basic_request common::basic_request::basic_request]

[indexterm2 basic_request..common::basic_request] 

  ``[link cgi.reference.common__basic_request.basic_request.overload1 basic_request]``(
      int opts,
      char ** base_env = NULL);

  ``[link cgi.reference.common__basic_request.basic_request.overload2 basic_request]``(
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);

  ``[link cgi.reference.common__basic_request.basic_request.overload3 basic_request]``(
      boost::system::error_code & ec,
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);

  ``[link cgi.reference.common__basic_request.basic_request.overload4 basic_request]``(
      protocol_service_type & s,
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);

  ``[link cgi.reference.common__basic_request.basic_request.overload5 basic_request]``(
      protocol_service_type & s,
      boost::system::error_code & ec,
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);

  ``[link cgi.reference.common__basic_request.basic_request.overload6 basic_request]``(
      implementation_type & impl);

  ``[link cgi.reference.common__basic_request.basic_request.overload7 basic_request]``(
      implementation_type & impl,
      boost::system::error_code & ec);


[section:overload1 common::basic_request::basic_request (1 of 7 overloads)]



  basic_request(
      int opts,
      char ** base_env = NULL);



[endsect]



[section:overload2 common::basic_request::basic_request (2 of 7 overloads)]



  basic_request(
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);



[endsect]



[section:overload3 common::basic_request::basic_request (3 of 7 overloads)]



  basic_request(
      boost::system::error_code & ec,
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);



[endsect]



[section:overload4 common::basic_request::basic_request (4 of 7 overloads)]



  basic_request(
      protocol_service_type & s,
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);



[endsect]



[section:overload5 common::basic_request::basic_request (5 of 7 overloads)]



  basic_request(
      protocol_service_type & s,
      boost::system::error_code & ec,
      const parse_options opts = traits::parse_opts,
      char ** base_env = NULL);



[endsect]



[section:overload6 common::basic_request::basic_request (6 of 7 overloads)]

Make a new mutiplexed request from an existing connection. 

  basic_request(
      implementation_type & impl);



[endsect]



[section:overload7 common::basic_request::basic_request (7 of 7 overloads)]

Make a new mutiplexed request from an existing connection. 

  basic_request(
      implementation_type & impl,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:buffer_type common::basic_request::buffer_type]

[indexterm2 buffer_type..common::basic_request] 

  typedef traits::buffer_type buffer_type;




[endsect]



[section:char_type common::basic_request::char_type]

[indexterm2 char_type..common::basic_request] 

  typedef traits::char_type char_type;




[endsect]



[section:charset common::basic_request::charset]

[indexterm2 charset..common::basic_request] Get the charset from the CONTENT_TYPE header. 

  string_type charset();



[endsect]



[section:clear common::basic_request::clear]

[indexterm2 clear..common::basic_request] Clear the data for the request, for reusing this object. 

  void clear();



[endsect]



[section:client common::basic_request::client]

[indexterm2 client..common::basic_request] Get the client connection associated with the request. 

  client_type & client();


You use the client for read/write calls. 


[endsect]



[section:client_type common::basic_request::client_type]

[indexterm2 client_type..common::basic_request] 

  typedef traits::client_type client_type;




[endsect]


[section:close common::basic_request::close]

[indexterm2 close..common::basic_request] Asynchronously read/parse the request meta-data. 

  int ``[link cgi.reference.common__basic_request.close.overload1 close]``(
      common::http::status_code http_status = http::ok,
      int program_status = 0);

  int ``[link cgi.reference.common__basic_request.close.overload2 close]``(
      common::http::status_code http_status,
      int program_status,
      boost::system::error_code & ec);


[section:overload1 common::basic_request::close (1 of 2 overloads)]

Asynchronously read/parse the request meta-data. 

  int close(
      common::http::status_code http_status = http::ok,
      int program_status = 0);


Note: 'loading' including reading/parsing STDIN if parse\_stdin == true Notify the server the request has been handled. In certain situations (such as a Proactor client using the async read functions) it will be necessary to call end, rather than just returning from the sub\_main function.


[heading Parameters]
    

[variablelist
  
[[http_status][The HTTP status of the request.]]

[[program_status][This value is returned to the server indicating the state of the request after it was finished handling. It is implementation defined how the server deals with this, and it may have no effect on the http status code returned to the client (eg. 200 OK).]]

]

[heading Return Value]
      
The value of program\_status 



[endsect]



[section:overload2 common::basic_request::close (2 of 2 overloads)]



  int close(
      common::http::status_code http_status,
      int program_status,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:content_length common::basic_request::content_length]

[indexterm2 content_length..common::basic_request] Get the content length as a long. 

  long content_length();


The content length defaults to zero if it isn't explicitly set by your HTTP server. 


[endsect]



[section:content_type common::basic_request::content_type]

[indexterm2 content_type..common::basic_request] The content type of the request. 

  string_type & content_type();


Common value: text/html. 


[endsect]



[section:cookies common::basic_request::cookies]

[indexterm2 cookies..common::basic_request] 

  common::data_map_proxy< cookie_map > cookies;



[endsect]


[section:create common::basic_request::create]

[indexterm2 create..common::basic_request] 

  static pointer ``[link cgi.reference.common__basic_request.create.overload1 create]``(
      protocol_service_type & ps);

  static pointer ``[link cgi.reference.common__basic_request.create.overload2 create]``();


[section:overload1 common::basic_request::create (1 of 2 overloads)]



  static pointer create(
      protocol_service_type & ps);



[endsect]



[section:overload2 common::basic_request::create (2 of 2 overloads)]



  static pointer create();



[endsect]


[endsect]


[section:env common::basic_request::env]

[indexterm2 env..common::basic_request] 

  common::data_map_proxy< env_map > env;



[endsect]



[section:form common::basic_request::form]

[indexterm2 form..common::basic_request] 

  common::data_map_proxy< form_map > form;



[endsect]



[section:gateway_interface common::basic_request::gateway_interface]

[indexterm2 gateway_interface..common::basic_request] The protocol used by the server to communicate to the script. 

  string_type & gateway_interface();


Common value: CGI/1.1. 


[endsect]



[section:get common::basic_request::get]

[indexterm2 get..common::basic_request] 

  common::data_map_proxy< get_map > get;



[endsect]



[section:hash common::basic_request::hash]

[indexterm2 hash..common::basic_request] Get a hashed interpretation of the request. 

  std::size_t hash();


You cannot consider this completely unique to each request, but it should be quite useful anyway. You can use this for logging or tracking, for example. 


[endsect]



[section:http_cookie common::basic_request::http_cookie]

[indexterm2 http_cookie..common::basic_request] The cookies sent by the user making the request. 

  string_type & http_cookie();



[endsect]



[section:http_from common::basic_request::http_from]

[indexterm2 http_from..common::basic_request] The email of the user making the request. 

  string_type & http_from();



[endsect]



[section:id common::basic_request::id]

[indexterm2 id..common::basic_request] The id of this request. 

  int id();


This is 1 for CGI/aCGI requests, but may be != 1 for FastCGI requests.

Note that for FastCGI requests, the id's are assigned on a *per-connection* policy, so in one application you may have several requests with the same id. 


[endsect]



[section:implementation_type common::basic_request::implementation_type]

[indexterm2 implementation_type..common::basic_request] 

  typedef service_type::implementation_type implementation_type;




[endsect]



[section:is_open common::basic_request::is_open]

[indexterm2 is_open..common::basic_request] Check if the request is still open (ie. not aborted or closed). 

  bool is_open();



[endsect]


[section:load common::basic_request::load]

[indexterm2 load..common::basic_request] Synchronously read/parse the request meta-data. 

  void ``[link cgi.reference.common__basic_request.load.overload1 load]``(
      parse_options parse_opts = parse_env,
      char ** base_env = NULL);

  boost::system::error_code ``[link cgi.reference.common__basic_request.load.overload2 load]``(
      parse_options parse_opts,
      boost::system::error_code & ec,
      char ** base_environment = NULL,
      bool is_command_line = true);

  void ``[link cgi.reference.common__basic_request.load.overload3 load]``(
      char ** base_environment,
      bool is_command_line = true);


[section:overload1 common::basic_request::load (1 of 3 overloads)]

Synchronously read/parse the request meta-data. 

  void load(
      parse_options parse_opts = parse_env,
      char ** base_env = NULL);


Note: 'loading' including reading/parsing STDIN if parse\_stdin == true 


[endsect]



[section:overload2 common::basic_request::load (2 of 3 overloads)]



  boost::system::error_code load(
      parse_options parse_opts,
      boost::system::error_code & ec,
      char ** base_environment = NULL,
      bool is_command_line = true);



[endsect]



[section:overload3 common::basic_request::load (3 of 3 overloads)]



  void load(
      char ** base_environment,
      bool is_command_line = true);



[endsect]


[endsect]


[section:method common::basic_request::method]

[indexterm2 method..common::basic_request] The method of the request. 

  string_type & method();


Common values: `GET`, `POST`, `HEAD`. 


[endsect]



[section:path_info common::basic_request::path_info]

[indexterm2 path_info..common::basic_request] Additional information, appendended to the script. 

  common::path_info path_info();



[endsect]



[section:path_translated common::basic_request::path_translated]

[indexterm2 path_translated..common::basic_request] The translated version of the path info. 

  string_type & path_translated();


Your HTTP server may provide this, depending on configuration. The path info can represent a resource on the local file system. 


[endsect]



[section:pointer common::basic_request::pointer]

[indexterm2 pointer..common::basic_request] 

  typedef traits::pointer pointer;




[endsect]



[section:post common::basic_request::post]

[indexterm2 post..common::basic_request] 

  common::data_map_proxy< post_map > post;



[endsect]



[section:post_buffer common::basic_request::post_buffer]

[indexterm2 post_buffer..common::basic_request] Get the buffer containing the POST data. 

  buffer_type & post_buffer();


**FIXME** This actually returns the whole buffer on FastCGI at the moment, which contains the params too. 


[endsect]



[section:protocol_service_type common::basic_request::protocol_service_type]

[indexterm2 protocol_service_type..common::basic_request] 

  typedef traits::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type common::basic_request::protocol_type]

[indexterm2 protocol_type..common::basic_request] 

  typedef Protocol protocol_type;




[endsect]



[section:query_string common::basic_request::query_string]

[indexterm2 query_string..common::basic_request] The query string for the request. 

  string_type & query_string();


This is the part of the request URI after a '?'. A GET request passes request parameters, URL encoded in the query string. 


[endsect]


[section:read_some common::basic_request::read_some]

[indexterm2 read_some..common::basic_request] Read some data into the request, parsing if necessary. 

  void ``[link cgi.reference.common__basic_request.read_some.overload1 read_some]``();

  std::size_t ``[link cgi.reference.common__basic_request.read_some.overload2 read_some]``(
      boost::system::error_code & ec);

  template<
      typename MutableBufferSequence >
  void ``[link cgi.reference.common__basic_request.read_some.overload3 read_some]``(
      const MutableBufferSequence & buf);

  template<
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_request.read_some.overload4 read_some]``(
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);


[section:overload1 common::basic_request::read_some (1 of 4 overloads)]

Read some data into the request, parsing if necessary. 

  void read_some();



[endsect]



[section:overload2 common::basic_request::read_some (2 of 4 overloads)]

Read some data into the request, parsing if necessary. 

  std::size_t read_some(
      boost::system::error_code & ec);



[endsect]



[section:overload3 common::basic_request::read_some (3 of 4 overloads)]

Read some data into the supplied buffer, parsing if necessary. 

  template<
      typename MutableBufferSequence >
  void read_some(
      const MutableBufferSequence & buf);



[endsect]



[section:overload4 common::basic_request::read_some (4 of 4 overloads)]

Read some data into the supplied buffer, parsing if necessary. 

  template<
      typename MutableBufferSequence >
  std::size_t read_some(
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:referer common::basic_request::referer]

[indexterm2 referer..common::basic_request] Get the web page the user came from. 

  string_type & referer();


HTTP equivalent: `HTTP\_REFERER`

The referer is commonly used for tracking user's movements and origins. For instance, some sites use this to highlight some keywords on the page when users come from a search engine.

Note that you cannot ever guarantee on this value being either set or accurate. 


[endsect]



[section:reject common::basic_request::reject]

[indexterm2 reject..common::basic_request] Reject the request with a '500 Internal Server Error' error. 

  int reject();



[endsect]



[section:remote_addr common::basic_request::remote_addr]

[indexterm2 remote_addr..common::basic_request] The host address of the remote user. 

  string_type & remote_addr();



[endsect]



[section:remote_host common::basic_request::remote_host]

[indexterm2 remote_host..common::basic_request] The host name of the remote user's machine. 

  string_type & remote_host();



[endsect]



[section:remote_ident common::basic_request::remote_ident]

[indexterm2 remote_ident..common::basic_request] The user making the request. 

  string_type & remote_ident();



[endsect]



[section:remote_user common::basic_request::remote_user]

[indexterm2 remote_user..common::basic_request] The userid of the person accessing the script. 

  string_type & remote_user();



[endsect]



[section:request_method common::basic_request::request_method]

[indexterm2 request_method..common::basic_request] The method of the request (long-hand of `method()`). 

  string_type & request_method();


Common values: `GET`, `POST`, `HEAD`. 


[endsect]



[section:request_uri common::basic_request::request_uri]

[indexterm2 request_uri..common::basic_request] Get the URI of the request (long-hand of `uri()`). 

  string_type & request_uri();



[endsect]



[section:role common::basic_request::role]

[indexterm2 role..common::basic_request] The role that the request is playing. 

  role_type & role() const;


The default role type is responder.

In some cases - for instance with FastCGI - the role type can be different eg. `authorizer`, or `filter`. 


[endsect]



[section:script_name common::basic_request::script_name]

[indexterm2 script_name..common::basic_request] The name of the script. 

  string_type & script_name();



[endsect]



[section:script_uri common::basic_request::script_uri]

[indexterm2 script_uri..common::basic_request] The full URI of the script. 

  string_type & script_uri();



[endsect]



[section:script_url common::basic_request::script_url]

[indexterm2 script_url..common::basic_request] The URL of the script. 

  string_type & script_url();



[endsect]



[section:self_type common::basic_request::self_type]

[indexterm2 self_type..common::basic_request] 

  typedef basic_request< Protocol > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.service_type [*service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request.abort [*abort]]]
    [Abort a request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.auth_type [*auth_type]]]
    [Set the output for the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.basic_request [*basic_request]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.charset [*charset]]]
    [Get the charset from the CONTENT_TYPE header. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.clear [*clear]]]
    [Clear the data for the request, for reusing this object. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.client [*client]]]
    [Get the client connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.close [*close]]]
    [Asynchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.content_length [*content_length]]]
    [Get the content length as a long. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.content_type [*content_type]]]
    [The content type of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.gateway_interface [*gateway_interface]]]
    [The protocol used by the server to communicate to the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.hash [*hash]]]
    [Get a hashed interpretation of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.http_cookie [*http_cookie]]]
    [The cookies sent by the user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.http_from [*http_from]]]
    [The email of the user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.id [*id]]]
    [The id of this request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.is_open [*is_open]]]
    [Check if the request is still open (ie. not aborted or closed). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.method [*method]]]
    [The method of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.path_info [*path_info]]]
    [Additional information, appendended to the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.path_translated [*path_translated]]]
    [The translated version of the path info. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.post_buffer [*post_buffer]]]
    [Get the buffer containing the POST data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.query_string [*query_string]]]
    [The query string for the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.read_some [*read_some]]]
    [Read some data into the request, parsing if necessary. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.referer [*referer]]]
    [Get the web page the user came from. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.reject [*reject]]]
    [Reject the request with a '500 Internal Server Error' error. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_addr [*remote_addr]]]
    [The host address of the remote user. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_host [*remote_host]]]
    [The host name of the remote user's machine. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_ident [*remote_ident]]]
    [The user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_user [*remote_user]]]
    [The userid of the person accessing the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.request_method [*request_method]]]
    [The method of the request (long-hand of `method()`). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.request_uri [*request_uri]]]
    [Get the URI of the request (long-hand of `uri()`). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.role [*role]]]
    [The role that the request is playing. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_name [*script_name]]]
    [The name of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_uri [*script_uri]]]
    [The full URI of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_url [*script_url]]]
    [The URL of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_name [*server_name]]]
    [Get the name of the server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_port [*server_port]]]
    [Get the port the calling server is listening on. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_protocol [*server_protocol]]]
    [Get the protocol being used by the calling server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_software [*server_software]]]
    [Get a string identifying the calling server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.status [*status]]]
    [Get / Set the status of a request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.uri [*uri]]]
    [Get the URI of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request._basic_request [*~basic_request]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request.cookies [*cookies]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.env [*env]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.form [*form]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.get [*get]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.post [*post]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.uploads [*uploads]]]
    []
  ]

]

Note: By default, synchronous protocols (ie. cgi) auto-load AND parse STDIN,whereas async protocols don't.

Note: The alternative functions which take a boost::system::error\_code are the non-throwing versions. Instead of a boost::system::system\_error being thrown in case of an error, the passed error\_code will be set to the value of the error, s.t. if (error) evaluates to true.`

Note: This class isn't thread safe: carrying around a mutex-per-request seems prohibitively expensive. There could be functions which take a mutex as an argument and lock it. (Async calls could get messy if you need a protected request object). 



[endsect]



[section:server_name common::basic_request::server_name]

[indexterm2 server_name..common::basic_request] Get the name of the server. 

  string_type & server_name();


Usually set in your HTTP configuration. This could be the name of a virtual host. 


[endsect]



[section:server_port common::basic_request::server_port]

[indexterm2 server_port..common::basic_request] Get the port the calling server is listening on. 

  string_type & server_port();


Common value: 80. 


[endsect]



[section:server_protocol common::basic_request::server_protocol]

[indexterm2 server_protocol..common::basic_request] Get the protocol being used by the calling server. 

  string_type & server_protocol();


Common value: HTTP/1.1. 


[endsect]



[section:server_software common::basic_request::server_software]

[indexterm2 server_software..common::basic_request] Get a string identifying the calling server. 

  string_type & server_software();


CGI scripts are generally called by a web-facing HTTP server. When set, this string can be useful for knowing what is calling the script, especially in a multi-server or load balanced environment. 


[endsect]



[section:service_type common::basic_request::service_type]

[indexterm2 service_type..common::basic_request] 

  typedef traits::service_type service_type;




[endsect]



[section:set_protocol_service common::basic_request::set_protocol_service]

[indexterm2 set_protocol_service..common::basic_request] 

  void set_protocol_service(
      protocol_service_type & ps);



[endsect]


[section:status common::basic_request::status]

[indexterm2 status..common::basic_request] Get / Set the status of a request. 

  common::request_status ``[link cgi.reference.common__basic_request.status.overload1 status]``() const;

  void ``[link cgi.reference.common__basic_request.status.overload2 status]``(
      common::request_status const & status);

  common::http::status_code ``[link cgi.reference.common__basic_request.status.overload3 status]``(
      common::http::status_code const & status) const;

  void ``[link cgi.reference.common__basic_request.status.overload4 status]``(
      common::http::status_code const & status);


[section:overload1 common::basic_request::status (1 of 4 overloads)]

Get / Set the status of a request. 

  common::request_status status() const;


The usual way to set the request status is to set it when calling `close`. 


[endsect]



[section:overload2 common::basic_request::status (2 of 4 overloads)]



  void status(
      common::request_status const & status);



[endsect]



[section:overload3 common::basic_request::status (3 of 4 overloads)]



  common::http::status_code status(
      common::http::status_code const & status) const;



[endsect]



[section:overload4 common::basic_request::status (4 of 4 overloads)]



  void status(
      common::http::status_code const & status);



[endsect]


[endsect]


[section:string_type common::basic_request::string_type]

[indexterm2 string_type..common::basic_request] 

  typedef traits::string_type string_type;




[endsect]



[section:traits common::basic_request::traits]

[indexterm2 traits..common::basic_request] 

  typedef detail::protocol_traits< protocol_type > traits;




[endsect]



[section:uploads common::basic_request::uploads]

[indexterm2 uploads..common::basic_request] 

  common::data_map_proxy< upload_map > uploads;



[endsect]



[section:uri common::basic_request::uri]

[indexterm2 uri..common::basic_request] Get the URI of the request. 

  string_type & uri();



[endsect]



[section:_basic_request common::basic_request::~basic_request]

[indexterm2 ~basic_request..common::basic_request] 

  ~basic_request();



[endsect]



[endsect]

[section:common__basic_request_acceptor common::basic_request_acceptor]

The interface class for any *BOOST_CGI_NAMESPACEacceptor. 

  template<
      typename RequestAcceptorService >
  class basic_request_acceptor


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request_acceptor.accept_handler_type [*accept_handler_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.endpoint_type [*endpoint_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.native_type [*native_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.next_layer_type [*next_layer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.port_number_type [*port_number_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request_acceptor.service_type [*service_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request_acceptor.accept [*accept]]]
    [Accept one request and handle it with `handler`. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.assign [*assign]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.async_accept [*async_accept]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor [*basic_request_acceptor]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.bind [*bind]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.cancel [*cancel]]]
    [Cancel all asynchronous operations associated with the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.close [*close]]]
    [Close the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.is_open [*is_open]]]
    [Check if the acceptor is open. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.listen [*listen]]]
    [Set the acceptor to listen. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.local_endpoint [*local_endpoint]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.native [*native]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.open [*open]]]
    [Open the acceptor. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor.protocol_service [*protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request_acceptor._basic_request_acceptor [*~basic_request_acceptor]]]
    []
  ]
  
]

[section:accept common::basic_request_acceptor::accept]

[indexterm2 accept..common::basic_request_acceptor] Accept one request and handle it with `handler`. 

  int ``[link cgi.reference.common__basic_request_acceptor.accept.overload1 accept]``(
      accept_handler_type handler);

  int ``[link cgi.reference.common__basic_request_acceptor.accept.overload2 accept]``(
      accept_handler_type handler,
      boost::system::error_code & ec);

  template<
      typename CommonGatewayRequest >
  void ``[link cgi.reference.common__basic_request_acceptor.accept.overload3 accept]``(
      CommonGatewayRequest & request);

  template<
      typename CommonGatewayRequest >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.accept.overload4 accept]``(
      CommonGatewayRequest & request,
      boost::system::error_code & ec);

  template<
      typename CommonGatewayRequest >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.accept.overload5 accept]``(
      CommonGatewayRequest & request,
      endpoint_type & ep,
      boost::system::error_code & ec);


[section:overload1 common::basic_request_acceptor::accept (1 of 5 overloads)]

Accept one request and handle it with `handler`. 

  int accept(
      accept_handler_type handler);



[endsect]



[section:overload2 common::basic_request_acceptor::accept (2 of 5 overloads)]



  int accept(
      accept_handler_type handler,
      boost::system::error_code & ec);



[endsect]



[section:overload3 common::basic_request_acceptor::accept (3 of 5 overloads)]



  template<
      typename CommonGatewayRequest >
  void accept(
      CommonGatewayRequest & request);



[endsect]



[section:overload4 common::basic_request_acceptor::accept (4 of 5 overloads)]

Accept one request. 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      CommonGatewayRequest & request,
      boost::system::error_code & ec);



[endsect]



[section:overload5 common::basic_request_acceptor::accept (5 of 5 overloads)]



  template<
      typename CommonGatewayRequest >
  boost::system::error_code accept(
      CommonGatewayRequest & request,
      endpoint_type & ep,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:accept_handler_type common::basic_request_acceptor::accept_handler_type]

[indexterm2 accept_handler_type..common::basic_request_acceptor] 

  typedef service_type::accept_handler_type accept_handler_type;




[endsect]


[section:assign common::basic_request_acceptor::assign]

[indexterm2 assign..common::basic_request_acceptor] 

  template<
      typename Protocol >
  void ``[link cgi.reference.common__basic_request_acceptor.assign.overload1 assign]``(
      Protocol protocol,
      const native_type & native_acceptor);

  template<
      typename Protocol >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.assign.overload2 assign]``(
      Protocol protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);


[section:overload1 common::basic_request_acceptor::assign (1 of 2 overloads)]



  template<
      typename Protocol >
  void assign(
      Protocol protocol,
      const native_type & native_acceptor);



[endsect]



[section:overload2 common::basic_request_acceptor::assign (2 of 2 overloads)]



  template<
      typename Protocol >
  boost::system::error_code assign(
      Protocol protocol,
      const native_type & native_acceptor,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:async_accept common::basic_request_acceptor::async_accept]

[indexterm2 async_accept..common::basic_request_acceptor] 

  void ``[link cgi.reference.common__basic_request_acceptor.async_accept.overload1 async_accept]``(
      accept_handler_type handler);

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void ``[link cgi.reference.common__basic_request_acceptor.async_accept.overload2 async_accept]``(
      CommonGatewayRequest & request,
      Handler handler);


[section:overload1 common::basic_request_acceptor::async_accept (1 of 2 overloads)]



  void async_accept(
      accept_handler_type handler);



[endsect]



[section:overload2 common::basic_request_acceptor::async_accept (2 of 2 overloads)]

Asynchronously accept one request. 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void async_accept(
      CommonGatewayRequest & request,
      Handler handler);



[endsect]


[endsect]

[section:basic_request_acceptor common::basic_request_acceptor::basic_request_acceptor]

[indexterm2 basic_request_acceptor..common::basic_request_acceptor] 

  template<
      typename IoServiceProvider >
  ``[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor.overload1 basic_request_acceptor]``(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      port_number_type port_num = 0);

  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  ``[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor.overload2 basic_request_acceptor]``(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const boost::asio::ip::basic_endpoint< InternetProtocol > & endpoint,
      bool reuse_addr = true);

  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  ``[link cgi.reference.common__basic_request_acceptor.basic_request_acceptor.overload3 basic_request_acceptor]``(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const InternetProtocol & ip,
      const native_type & native_acceptor);


[section:overload1 common::basic_request_acceptor::basic_request_acceptor (1 of 3 overloads)]



  template<
      typename IoServiceProvider >
  basic_request_acceptor(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      port_number_type port_num = 0);



[endsect]



[section:overload2 common::basic_request_acceptor::basic_request_acceptor (2 of 3 overloads)]



  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  basic_request_acceptor(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const boost::asio::ip::basic_endpoint< InternetProtocol > & endpoint,
      bool reuse_addr = true);



[endsect]



[section:overload3 common::basic_request_acceptor::basic_request_acceptor (3 of 3 overloads)]



  template<
      typename IoServiceProvider ,
      typename InternetProtocol >
  basic_request_acceptor(
      common::basic_protocol_service< protocol_type, IoServiceProvider > & ps,
      const InternetProtocol & ip,
      const native_type & native_acceptor);



[endsect]


[endsect]

[section:bind common::basic_request_acceptor::bind]

[indexterm2 bind..common::basic_request_acceptor] 

  template<
      typename Endpoint >
  void ``[link cgi.reference.common__basic_request_acceptor.bind.overload1 bind]``(
      Endpoint & ep);

  template<
      typename Endpoint >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.bind.overload2 bind]``(
      Endpoint & ep,
      boost::system::error_code & ec);


[section:overload1 common::basic_request_acceptor::bind (1 of 2 overloads)]



  template<
      typename Endpoint >
  void bind(
      Endpoint & ep);



[endsect]



[section:overload2 common::basic_request_acceptor::bind (2 of 2 overloads)]



  template<
      typename Endpoint >
  boost::system::error_code bind(
      Endpoint & ep,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:cancel common::basic_request_acceptor::cancel]

[indexterm2 cancel..common::basic_request_acceptor] Cancel all asynchronous operations associated with the acceptor. 

  boost::system::error_code cancel();



[endsect]


[section:close common::basic_request_acceptor::close]

[indexterm2 close..common::basic_request_acceptor] Close the acceptor. 

  void ``[link cgi.reference.common__basic_request_acceptor.close.overload1 close]``();

  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.close.overload2 close]``(
      boost::system::error_code & ec);


[section:overload1 common::basic_request_acceptor::close (1 of 2 overloads)]

Close the acceptor. 

  void close();



[endsect]



[section:overload2 common::basic_request_acceptor::close (2 of 2 overloads)]

Close the acceptor. 

  boost::system::error_code close(
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:endpoint_type common::basic_request_acceptor::endpoint_type]

[indexterm2 endpoint_type..common::basic_request_acceptor] 

  typedef service_type::endpoint_type endpoint_type;




[endsect]



[section:is_cgi common::basic_request_acceptor::is_cgi]

[indexterm2 is_cgi..common::basic_request_acceptor] 

  bool is_cgi();



[endsect]



[section:is_open common::basic_request_acceptor::is_open]

[indexterm2 is_open..common::basic_request_acceptor] Check if the acceptor is open. 

  bool is_open();



[endsect]


[section:listen common::basic_request_acceptor::listen]

[indexterm2 listen..common::basic_request_acceptor] Set the acceptor to listen. 

  void ``[link cgi.reference.common__basic_request_acceptor.listen.overload1 listen]``(
      int backlog = boost::asio::socket_base::max_connections);

  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.listen.overload2 listen]``(
      int backlog,
      boost::system::error_code & ec);


[section:overload1 common::basic_request_acceptor::listen (1 of 2 overloads)]

Set the acceptor to listen. 

  void listen(
      int backlog = boost::asio::socket_base::max_connections);



[endsect]



[section:overload2 common::basic_request_acceptor::listen (2 of 2 overloads)]

Set the acceptor to listen. 

  boost::system::error_code listen(
      int backlog,
      boost::system::error_code & ec);



[endsect]


[endsect]

[section:local_endpoint common::basic_request_acceptor::local_endpoint]

[indexterm2 local_endpoint..common::basic_request_acceptor] 

  endpoint_type ``[link cgi.reference.common__basic_request_acceptor.local_endpoint.overload1 local_endpoint]``();

  endpoint_type ``[link cgi.reference.common__basic_request_acceptor.local_endpoint.overload2 local_endpoint]``(
      boost::system::error_code & ec) const;


[section:overload1 common::basic_request_acceptor::local_endpoint (1 of 2 overloads)]



  endpoint_type local_endpoint();



[endsect]



[section:overload2 common::basic_request_acceptor::local_endpoint (2 of 2 overloads)]



  endpoint_type local_endpoint(
      boost::system::error_code & ec) const;



[endsect]


[endsect]


[section:native common::basic_request_acceptor::native]

[indexterm2 native..common::basic_request_acceptor] 

  native_type native();



[endsect]



[section:native_type common::basic_request_acceptor::native_type]

[indexterm2 native_type..common::basic_request_acceptor] 

  typedef service_type::native_type native_type;




[endsect]



[section:next_layer_type common::basic_request_acceptor::next_layer_type]

[indexterm2 next_layer_type..common::basic_request_acceptor] 

  typedef service_type::acceptor_service_type next_layer_type;




[endsect]


[section:open common::basic_request_acceptor::open]

[indexterm2 open..common::basic_request_acceptor] Open the acceptor. 

  template<
      typename Protocol >
  void ``[link cgi.reference.common__basic_request_acceptor.open.overload1 open]``(
      const Protocol & protocol);

  template<
      typename Protocol >
  boost::system::error_code ``[link cgi.reference.common__basic_request_acceptor.open.overload2 open]``(
      const Protocol & protocol,
      boost::system::error_code & ec);


[section:overload1 common::basic_request_acceptor::open (1 of 2 overloads)]

Open the acceptor. 

  template<
      typename Protocol >
  void open(
      const Protocol & protocol);



[endsect]



[section:overload2 common::basic_request_acceptor::open (2 of 2 overloads)]

Open the acceptor. 

  template<
      typename Protocol >
  boost::system::error_code open(
      const Protocol & protocol,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:port_number_type common::basic_request_acceptor::port_number_type]

[indexterm2 port_number_type..common::basic_request_acceptor] 

  typedef service_type::implementation_type::port_number_type port_number_type;




[endsect]



[section:protocol_service common::basic_request_acceptor::protocol_service]

[indexterm2 protocol_service..common::basic_request_acceptor] 

  protocol_service_type & protocol_service() const;



[endsect]



[section:protocol_service_type common::basic_request_acceptor::protocol_service_type]

[indexterm2 protocol_service_type..common::basic_request_acceptor] 

  typedef service_type::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type common::basic_request_acceptor::protocol_type]

[indexterm2 protocol_type..common::basic_request_acceptor] 

  typedef service_type::protocol_type protocol_type;




[endsect]



[section:service_type common::basic_request_acceptor::service_type]

[indexterm2 service_type..common::basic_request_acceptor] 

  typedef RequestAcceptorService service_type;




[endsect]



[section:_basic_request_acceptor common::basic_request_acceptor::~basic_request_acceptor]

[indexterm2 ~basic_request_acceptor..common::basic_request_acceptor] 

  ~basic_request_acceptor();



[endsect]



[endsect]

[section:common__basic_response common::basic_response]

The response class: a helper for responding to requests. 

  template<
      typename ``[link cgi.reference.CharT CharT]``>
  class basic_response


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_response.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.ostream_type [*ostream_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.async_send [*async_send]]]
    [Asynchronously send the data through the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.basic_response [*basic_response]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.charset [*charset]]]
    [Get the charset. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear [*clear]]]
    [Clear the response buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear_headers [*clear_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.content_length [*content_length]]]
    [Get the length of the body of the response (ie. not including the headers). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.do_async_send [*do_async_send]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.end_headers [*end_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.flush [*flush]]]
    [Synchronously flush the data to the supplied SyncWriteStream. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.header_value [*header_value]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers [*headers]]]
    [Get the headers. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers_terminated [*headers_terminated]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.operator_lt__lt_ [*operator<<]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.ostream [*ostream]]]
    [Get the ostream containing the response body. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.rdbuf [*rdbuf]]]
    [Get the buffer associated with the stream. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.resend [*resend]]]
    [Resend headers + content regardless of value of `headers_terminated_`. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset [*reset]]]
    [Return the response to the 'just constructed' state. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset_headers [*reset_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.send [*send]]]
    [Synchronously send the data via the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set [*set]]]
    [Add a header after appending the CRLF sequence. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set_header [*set_header]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.status [*status]]]
    [Set the status code associated with the response. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.str [*str]]]
    [Get the contents of the response as a string. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.unterminate_headers [*unterminate_headers]]]
    [Allow more headers to be added (WARNING: avoid using this). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.write [*write]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response._basic_response [*~basic_response]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.buffer_ [*buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.charset_ [*charset_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_ [*headers_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_terminated_ [*headers_terminated_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.ostream_ [*ostream_]]]
    []
  ]

]


[section:async_send common::basic_response::async_send]

[indexterm2 async_send..common::basic_response] Asynchronously send the data through the supplied request. 

  template<
      typename AsyncWriteStream ,
      typename Handler >
  void async_send(
      AsyncWriteStream & aws,
      Handler handler);


Note: This is quite crude at the moment and not as asynchronous as it could/should be. The data in the stream isn't cleared after this call. 


[endsect]


[section:basic_response common::basic_response::basic_response]

[indexterm2 basic_response..common::basic_response] 

  ``[link cgi.reference.common__basic_response.basic_response.overload1 basic_response]``(
      common::http::status_code sc = common::http::ok);

  ``[link cgi.reference.common__basic_response.basic_response.overload2 basic_response]``(
      ::BOOST_CGI_NAMESPACE::common::streambuf * buf,
      common::http::status_code sc = common::http::ok);


[section:overload1 common::basic_response::basic_response (1 of 2 overloads)]



  basic_response(
      common::http::status_code sc = common::http::ok);



[endsect]



[section:overload2 common::basic_response::basic_response (2 of 2 overloads)]

Construct with a particular buffer. 

  basic_response(
      ::BOOST_CGI_NAMESPACE::common::streambuf * buf,
      common::http::status_code sc = common::http::ok);


Takes the buffer and uses it internally, does nothing with it on destruction. 


[endsect]


[endsect]


[section:buffer_ common::basic_response::buffer_]

[indexterm2 buffer_..common::basic_response] 

  boost::shared_ptr< common::streambuf > buffer_;



[endsect]



[section:char_type common::basic_response::char_type]

[indexterm2 char_type..common::basic_response] 

  typedef CharT char_type;




[endsect]


[section:charset common::basic_response::charset]

[indexterm2 charset..common::basic_response] Get the charset. 

  string_type & ``[link cgi.reference.common__basic_response.charset.overload1 charset]``() const;

  void ``[link cgi.reference.common__basic_response.charset.overload2 charset]``(
      string_type const & cs);


[section:overload1 common::basic_response::charset (1 of 2 overloads)]

Get the charset. 

  string_type & charset() const;



[endsect]



[section:overload2 common::basic_response::charset (2 of 2 overloads)]

Set the charset. 

  void charset(
      string_type const & cs);



[endsect]


[endsect]


[section:charset_ common::basic_response::charset_]

[indexterm2 charset_..common::basic_response] 

  string_type charset_;



[endsect]



[section:clear common::basic_response::clear]

[indexterm2 clear..common::basic_response] Clear the response buffer. 

  void clear(
      bool clear_headers = true);



[endsect]



[section:clear_headers common::basic_response::clear_headers]

[indexterm2 clear_headers..common::basic_response] 

  void clear_headers();



[endsect]



[section:content_length common::basic_response::content_length]

[indexterm2 content_length..common::basic_response] Get the length of the body of the response (ie. not including the headers). 

  std::size_t content_length();



[endsect]



[section:do_async_send common::basic_response::do_async_send]

[indexterm2 do_async_send..common::basic_response] 

  template<
      typename AsyncWriteStream ,
      typename Handler >
  void do_async_send(
      AsyncWriteStream & aws,
      Handler handler);



[endsect]



[section:end_headers common::basic_response::end_headers]

[indexterm2 end_headers..common::basic_response] 

  void end_headers();



[endsect]


[section:flush common::basic_response::flush]

[indexterm2 flush..common::basic_response] Synchronously flush the data to the supplied SyncWriteStream. 

  template<
      typename SyncWriteStream >
  void ``[link cgi.reference.common__basic_response.flush.overload1 flush]``(
      SyncWriteStream & sws);

  template<
      typename SyncWriteStream >
  boost::system::error_code ``[link cgi.reference.common__basic_response.flush.overload2 flush]``(
      SyncWriteStream & sws,
      boost::system::error_code & ec);


[section:overload1 common::basic_response::flush (1 of 2 overloads)]

Synchronously flush the data to the supplied SyncWriteStream. 

  template<
      typename SyncWriteStream >
  void flush(
      SyncWriteStream & sws);


This call uses throwing semantics. ie. an exception will be thrown on any failure. If there is no error, the buffer is cleared. 


[endsect]



[section:overload2 common::basic_response::flush (2 of 2 overloads)]

Synchronously flush the data via the supplied request. 

  template<
      typename SyncWriteStream >
  boost::system::error_code flush(
      SyncWriteStream & sws,
      boost::system::error_code & ec);


This call uses error\_code semantics. ie. ec is set if an error occurs. If there is no error, the buffer is cleared. 


[endsect]


[endsect]


[section:header_value common::basic_response::header_value]

[indexterm2 header_value..common::basic_response] 

  string_type header_value(
      string_type const & name);



[endsect]



[section:headers common::basic_response::headers]

[indexterm2 headers..common::basic_response] Get the headers. 

  std::vector< string_type > & headers();



[endsect]



[section:headers_ common::basic_response::headers_]

[indexterm2 headers_..common::basic_response] 

  std::vector< string_type > headers_;



[endsect]



[section:headers_terminated common::basic_response::headers_terminated]

[indexterm2 headers_terminated..common::basic_response] 

  bool headers_terminated() const;



[endsect]



[section:headers_terminated_ common::basic_response::headers_terminated_]

[indexterm2 headers_terminated_..common::basic_response] 

  bool headers_terminated_;



[endsect]



[section:http_status_ common::basic_response::http_status_]

[indexterm2 http_status_..common::basic_response] 

  http::status_code http_status_;



[endsect]


[section:operator_lt__lt_ common::basic_response::operator<<]

[indexterm2 operator<<..common::basic_response] 

  template<
      typename T >
  self_type & ``[link cgi.reference.common__basic_response.operator_lt__lt_.overload1 operator<<]``(
      T t);

  self_type & ``[link cgi.reference.common__basic_response.operator_lt__lt_.overload2 operator<<]``(
      charset_header< char_type > const & hdr);

  self_type & ``[link cgi.reference.common__basic_response.operator_lt__lt_.overload3 operator<<]``(
      basic_header< char_type > const & hdr);

  self_type & ``[link cgi.reference.common__basic_response.operator_lt__lt_.overload4 operator<<]``(
      basic_cookie< char_type > const & ck);

  self_type & ``[link cgi.reference.common__basic_response.operator_lt__lt_.overload5 operator<<]``(
      http::status_code stat);

  self_type & ``[link cgi.reference.common__basic_response.operator_lt__lt_.overload6 operator<<]``(
      self_type & other);


[section:overload1 common::basic_response::operator<< (1 of 6 overloads)]



  template<
      typename T >
  self_type & operator<<(
      T t);



[endsect]



[section:overload2 common::basic_response::operator<< (2 of 6 overloads)]



  self_type & operator<<(
      charset_header< char_type > const & hdr);



[endsect]



[section:overload3 common::basic_response::operator<< (3 of 6 overloads)]



  self_type & operator<<(
      basic_header< char_type > const & hdr);



[endsect]



[section:overload4 common::basic_response::operator<< (4 of 6 overloads)]



  self_type & operator<<(
      basic_cookie< char_type > const & ck);



[endsect]



[section:overload5 common::basic_response::operator<< (5 of 6 overloads)]



  self_type & operator<<(
      http::status_code stat);



[endsect]



[section:overload6 common::basic_response::operator<< (6 of 6 overloads)]



  self_type & operator<<(
      self_type & other);



[endsect]


[endsect]


[section:ostream common::basic_response::ostream]

[indexterm2 ostream..common::basic_response] Get the ostream containing the response body. 

  ostream_type & ostream();



[endsect]



[section:ostream_ common::basic_response::ostream_]

[indexterm2 ostream_..common::basic_response] 

  ostream_type ostream_;



[endsect]



[section:ostream_type common::basic_response::ostream_type]

[indexterm2 ostream_type..common::basic_response] 

  typedef std::basic_ostream< CharT > ostream_type;




[endsect]



[section:rdbuf common::basic_response::rdbuf]

[indexterm2 rdbuf..common::basic_response] Get the buffer associated with the stream. 

  common::streambuf * rdbuf();



[endsect]



[section:resend common::basic_response::resend]

[indexterm2 resend..common::basic_response] Resend headers + content regardless of value of `headers_terminated_`. 

  template<
      typename SyncWriteStream >
  void resend(
      SyncWriteStream & sws);



[endsect]



[section:reset common::basic_response::reset]

[indexterm2 reset..common::basic_response] Return the response to the 'just constructed' state. 

  void reset();



[endsect]



[section:reset_headers common::basic_response::reset_headers]

[indexterm2 reset_headers..common::basic_response] 

  void reset_headers();



[endsect]



[section:self_type common::basic_response::self_type]

[indexterm2 self_type..common::basic_response] 

  typedef basic_response< CharT > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_response.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.ostream_type [*ostream_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_response.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.async_send [*async_send]]]
    [Asynchronously send the data through the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.basic_response [*basic_response]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.charset [*charset]]]
    [Get the charset. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear [*clear]]]
    [Clear the response buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.clear_headers [*clear_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.content_length [*content_length]]]
    [Get the length of the body of the response (ie. not including the headers). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.do_async_send [*do_async_send]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.end_headers [*end_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.flush [*flush]]]
    [Synchronously flush the data to the supplied SyncWriteStream. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.header_value [*header_value]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers [*headers]]]
    [Get the headers. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.headers_terminated [*headers_terminated]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.operator_lt__lt_ [*operator<<]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.ostream [*ostream]]]
    [Get the ostream containing the response body. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.rdbuf [*rdbuf]]]
    [Get the buffer associated with the stream. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.resend [*resend]]]
    [Resend headers + content regardless of value of `headers_terminated_`. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset [*reset]]]
    [Return the response to the 'just constructed' state. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.reset_headers [*reset_headers]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.send [*send]]]
    [Synchronously send the data via the supplied request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set [*set]]]
    [Add a header after appending the CRLF sequence. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.set_header [*set_header]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response.status [*status]]]
    [Set the status code associated with the response. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.str [*str]]]
    [Get the contents of the response as a string. ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.unterminate_headers [*unterminate_headers]]]
    [Allow more headers to be added (WARNING: avoid using this). ]
  ]
  
  [
    [[link cgi.reference.common__basic_response.write [*write]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_response._basic_response [*~basic_response]]]
    []
  ]
  
]

[heading Protected Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_response.buffer_ [*buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.charset_ [*charset_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_ [*headers_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.headers_terminated_ [*headers_terminated_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_response.ostream_ [*ostream_]]]
    []
  ]

]



[endsect]


[section:send common::basic_response::send]

[indexterm2 send..common::basic_response] Synchronously send the data via the supplied request. 

  template<
      typename SyncWriteStream >
  void ``[link cgi.reference.common__basic_response.send.overload1 send]``(
      SyncWriteStream & sws);

  template<
      typename SyncWriteStream >
  boost::system::error_code ``[link cgi.reference.common__basic_response.send.overload2 send]``(
      SyncWriteStream & sws,
      boost::system::error_code & ec);


[section:overload1 common::basic_response::send (1 of 2 overloads)]

Synchronously send the data via the supplied request. 

  template<
      typename SyncWriteStream >
  void send(
      SyncWriteStream & sws);


This call uses throwing semantics. ie. an exception will be thrown on any failure. Note: The data in the stream isn't cleared after this call. 


[endsect]



[section:overload2 common::basic_response::send (2 of 2 overloads)]

Synchronously send the data via the supplied request. 

  template<
      typename SyncWriteStream >
  boost::system::error_code send(
      SyncWriteStream & sws,
      boost::system::error_code & ec);


This call will not throw, but will set `ec` such that `ec == true` if an error occurs. Details of the error are held in the `error\_code` object. 


[endsect]


[endsect]

[section:set common::basic_response::set]

[indexterm2 set..common::basic_response] Add a header after appending the CRLF sequence. 

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.set.overload1 set]``(
      basic_header< char_type > const & hdr);

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.set.overload2 set]``(
      const basic_cookie< char_type > & ck);


[section:overload1 common::basic_response::set (1 of 2 overloads)]

Add a header after appending the CRLF sequence. 

  basic_response< char_type > & set(
      basic_header< char_type > const & hdr);



[endsect]



[section:overload2 common::basic_response::set (2 of 2 overloads)]



  basic_response< char_type > & set(
      const basic_cookie< char_type > & ck);



[endsect]


[endsect]

[section:set_header common::basic_response::set_header]

[indexterm2 set_header..common::basic_response] 

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.set_header.overload1 set_header]``(
      const string_type & value);

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.set_header.overload2 set_header]``(
      string_type const & name,
      string_type const & value);


[section:overload1 common::basic_response::set_header (1 of 2 overloads)]



  basic_response< char_type > & set_header(
      const string_type & value);



[endsect]



[section:overload2 common::basic_response::set_header (2 of 2 overloads)]

Format and add a header given name and value, appending CRLF. 

  basic_response< char_type > & set_header(
      string_type const & name,
      string_type const & value);



[endsect]


[endsect]

[section:status common::basic_response::status]

[indexterm2 status..common::basic_response] Set the status code associated with the response. 

  basic_response< char_type > & ``[link cgi.reference.common__basic_response.status.overload1 status]``(
      const http::status_code & num);

  http::status_code ``[link cgi.reference.common__basic_response.status.overload2 status]``() const;


[section:overload1 common::basic_response::status (1 of 2 overloads)]

Set the status code associated with the response. 

  basic_response< char_type > & status(
      const http::status_code & num);



[endsect]



[section:overload2 common::basic_response::status (2 of 2 overloads)]

Get the status code associated with the response. 

  http::status_code status() const;



[endsect]


[endsect]


[section:str common::basic_response::str]

[indexterm2 str..common::basic_response] Get the contents of the response as a string. 

  string_type str(
      bool include_header = false) const;


This copies the contents of the response into a string. Headers aren't included in the dump unless `include\_header` is true. 


[endsect]



[section:string_type common::basic_response::string_type]

[indexterm2 string_type..common::basic_response] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[section:unterminate_headers common::basic_response::unterminate_headers]

[indexterm2 unterminate_headers..common::basic_response] Allow more headers to be added (WARNING: avoid using this). 

  void unterminate_headers();



[endsect]


[section:write common::basic_response::write]

[indexterm2 write..common::basic_response] 

  std::size_t ``[link cgi.reference.common__basic_response.write.overload1 write]``(
      const char_type * str,
      std::size_t len);

  std::size_t ``[link cgi.reference.common__basic_response.write.overload2 write]``(
      string_type const & str);

  template<
      typename ConstBufferSequence >
  std::size_t ``[link cgi.reference.common__basic_response.write.overload3 write]``(
      const ConstBufferSequence & buf);


[section:overload1 common::basic_response::write (1 of 3 overloads)]



  std::size_t write(
      const char_type * str,
      std::size_t len);



[endsect]



[section:overload2 common::basic_response::write (2 of 3 overloads)]



  std::size_t write(
      string_type const & str);



[endsect]



[section:overload3 common::basic_response::write (3 of 3 overloads)]



  template<
      typename ConstBufferSequence >
  std::size_t write(
      const ConstBufferSequence & buf);



[endsect]


[endsect]


[section:_basic_response common::basic_response::~basic_response]

[indexterm2 ~basic_response..common::basic_response] 

  ~basic_response();



[endsect]



[endsect]

[section:common__charset_header common::charset_header]



  template<
      typename CharT >
  struct charset_header


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__charset_header.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__charset_header.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__charset_header.charset_header [*charset_header]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__charset_header.content [*content]]]
    []
  ]

]


[section:char_type common::charset_header::char_type]

[indexterm2 char_type..common::charset_header] 

  typedef CharT char_type;




[endsect]



[section:charset_header common::charset_header::charset_header]

[indexterm2 charset_header..common::charset_header] 

  charset_header(
      const string_type & _content);



[endsect]



[section:content common::charset_header::content]

[indexterm2 content..common::charset_header] 

  string_type content;



[endsect]



[section:string_type common::charset_header::string_type]

[indexterm2 string_type..common::charset_header] 

  typedef std::basic_string< CharT > string_type;




[endsect]



[endsect]


[section:common__client_status common::client_status]

[indexterm1 common::client_status] 

  enum client_status

[heading Values]
[variablelist

  [
    [none_]
    []
  ]

  [
    [constructed]
    []
  ]

  [
    [params_read]
    []
  ]

  [
    [stdin_read]
    []
  ]

  [
    [end_request_sent]
    []
  ]

  [
    [closed_]
    []
  ]

]



[endsect]


[section:common__data_map_proxy common::data_map_proxy]

A proxy class to provide access to the data maps as member variables. 

  template<
      typename ``[link cgi.reference.MapType MapType]``>
  struct data_map_proxy


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__data_map_proxy.allocator_type [*allocator_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.const_iterator [*const_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.const_reverse_iterator [*const_reverse_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.iterator [*iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.key_type [*key_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.mapped_type [*mapped_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.reverse_iterator [*reverse_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.size_type [*size_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.value_type [*value_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__data_map_proxy.as [*as]]]
    [Get a value for the key as a specified type, with fallback. ]
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.begin [*begin]]]
    [Map iterators. ]
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.count [*count]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.empty [*empty]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.end [*end]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.operator_map_type_& [*operator map_type &]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.operator_not_ [*operator!]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.operator_openbrace__closebrace_ [*operator[]]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.pick [*pick]]]
    [Get a value for the key, with fallback. ]
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.rbegin [*rbegin]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.rend [*rend]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.self_type [*self_type]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.set [*set]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.size [*size]]]
    []
  ]
  
]

This wraps the underlying data map and exposes a std::map-like interface for the different data maps.

It also includes an as<> member function which casts the found data into any type the user specifies. 


[section:allocator_type common::data_map_proxy::allocator_type]

[indexterm2 allocator_type..common::data_map_proxy] 

  typedef map_type::allocator_type allocator_type;




[endsect]



[section:as common::data_map_proxy::as]

[indexterm2 as..common::data_map_proxy] Get a value for the key as a specified type, with fallback. 

  template<
      typename T >
  T as(
      key_type const & key,
      T const & default_value = T()) const;



[heading Parameters]
    

[variablelist
  
[[key][The name of CGI parameter to look for. ]]

[[default_value][The default return value. If no data exists in the map for the specified key, or the data cannot be converted into the type of the default\_ value, then this value is returned.]]

]

If the key cannot be found, returns a default-constructed object of type T.

If the key is found, attempts to convert the value into the type T. This throws a boost::bad\_lexical\_cast when it fails. 


[endsect]


[section:begin common::data_map_proxy::begin]

[indexterm2 begin..common::data_map_proxy] Map iterators. 

  iterator ``[link cgi.reference.common__data_map_proxy.begin.overload1 begin]``();

  const_iterator ``[link cgi.reference.common__data_map_proxy.begin.overload2 begin]``() const;


[section:overload1 common::data_map_proxy::begin (1 of 2 overloads)]

Map iterators. 

  iterator begin();



[endsect]



[section:overload2 common::data_map_proxy::begin (2 of 2 overloads)]



  const_iterator begin() const;



[endsect]


[endsect]


[section:clear common::data_map_proxy::clear]

[indexterm2 clear..common::data_map_proxy] 

  void clear();



[endsect]



[section:const_iterator common::data_map_proxy::const_iterator]

[indexterm2 const_iterator..common::data_map_proxy] 

  typedef map_type::const_iterator const_iterator;




[endsect]



[section:const_reverse_iterator common::data_map_proxy::const_reverse_iterator]

[indexterm2 const_reverse_iterator..common::data_map_proxy] 

  typedef map_type::const_reverse_iterator const_reverse_iterator;




[endsect]



[section:count common::data_map_proxy::count]

[indexterm2 count..common::data_map_proxy] 

  size_type count(
      const key_type & key);



[endsect]



[section:empty common::data_map_proxy::empty]

[indexterm2 empty..common::data_map_proxy] 

  bool empty();



[endsect]


[section:end common::data_map_proxy::end]

[indexterm2 end..common::data_map_proxy] 

  iterator ``[link cgi.reference.common__data_map_proxy.end.overload1 end]``();

  const_iterator ``[link cgi.reference.common__data_map_proxy.end.overload2 end]``() const;


[section:overload1 common::data_map_proxy::end (1 of 2 overloads)]



  iterator end();



[endsect]



[section:overload2 common::data_map_proxy::end (2 of 2 overloads)]



  const_iterator end() const;



[endsect]


[endsect]


[section:iterator common::data_map_proxy::iterator]

[indexterm2 iterator..common::data_map_proxy] 

  typedef map_type::iterator iterator;




[endsect]



[section:key_type common::data_map_proxy::key_type]

[indexterm2 key_type..common::data_map_proxy] 

  typedef map_type::key_type key_type;




[endsect]



[section:map_type common::data_map_proxy::map_type]

[indexterm2 map_type..common::data_map_proxy] 

  typedef MapType map_type;




[endsect]



[section:mapped_type common::data_map_proxy::mapped_type]

[indexterm2 mapped_type..common::data_map_proxy] 

  typedef map_type::mapped_type mapped_type;




[endsect]



[section:operator_map_type_& common::data_map_proxy::operator map_type &]

[indexterm2 operator map_type &..common::data_map_proxy] 

  operator map_type &();



[endsect]



[section:operator_not_ common::data_map_proxy::operator!]

[indexterm2 operator!..common::data_map_proxy] 

  bool operator!() const;



[endsect]


[section:operator_openbrace__closebrace_ common::data_map_proxy::operator[]]

[indexterm2 operator[]..common::data_map_proxy] 

  mapped_type & ``[link cgi.reference.common__data_map_proxy.operator_openbrace__closebrace_.overload1 operator[]]``(
      const char * varname);

  mapped_type & ``[link cgi.reference.common__data_map_proxy.operator_openbrace__closebrace_.overload2 operator[]]``(
      const char * varname) const;

  mapped_type & ``[link cgi.reference.common__data_map_proxy.operator_openbrace__closebrace_.overload3 operator[]]``(
      key_type const & varname);

  mapped_type const & ``[link cgi.reference.common__data_map_proxy.operator_openbrace__closebrace_.overload4 operator[]]``(
      key_type const & varname) const;


[section:overload1 common::data_map_proxy::operator[] (1 of 4 overloads)]



  mapped_type & operator[](
      const char * varname);



[endsect]



[section:overload2 common::data_map_proxy::operator[] (2 of 4 overloads)]



  mapped_type & operator[](
      const char * varname) const;



[endsect]



[section:overload3 common::data_map_proxy::operator[] (3 of 4 overloads)]



  mapped_type & operator[](
      key_type const & varname);



[endsect]



[section:overload4 common::data_map_proxy::operator[] (4 of 4 overloads)]



  mapped_type const & operator[](
      key_type const & varname) const;



[endsect]


[endsect]


[section:pick common::data_map_proxy::pick]

[indexterm2 pick..common::data_map_proxy] Get a value for the key, with fallback. 

  mapped_type const & pick(
      key_type const & key,
      mapped_type const & default_value) const;



[endsect]


[section:rbegin common::data_map_proxy::rbegin]

[indexterm2 rbegin..common::data_map_proxy] 

  reverse_iterator ``[link cgi.reference.common__data_map_proxy.rbegin.overload1 rbegin]``();

  const_reverse_iterator ``[link cgi.reference.common__data_map_proxy.rbegin.overload2 rbegin]``() const;


[section:overload1 common::data_map_proxy::rbegin (1 of 2 overloads)]



  reverse_iterator rbegin();



[endsect]



[section:overload2 common::data_map_proxy::rbegin (2 of 2 overloads)]



  const_reverse_iterator rbegin() const;



[endsect]


[endsect]

[section:rend common::data_map_proxy::rend]

[indexterm2 rend..common::data_map_proxy] 

  reverse_iterator ``[link cgi.reference.common__data_map_proxy.rend.overload1 rend]``();

  const_reverse_iterator ``[link cgi.reference.common__data_map_proxy.rend.overload2 rend]``() const;


[section:overload1 common::data_map_proxy::rend (1 of 2 overloads)]



  reverse_iterator rend();



[endsect]



[section:overload2 common::data_map_proxy::rend (2 of 2 overloads)]



  const_reverse_iterator rend() const;



[endsect]


[endsect]


[section:reverse_iterator common::data_map_proxy::reverse_iterator]

[indexterm2 reverse_iterator..common::data_map_proxy] 

  typedef map_type::reverse_iterator reverse_iterator;




[endsect]



[section:self_type common::data_map_proxy::self_type]

[indexterm2 self_type..common::data_map_proxy] 

  typedef data_map_proxy< map_type > self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__data_map_proxy.allocator_type [*allocator_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.const_iterator [*const_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.const_reverse_iterator [*const_reverse_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.iterator [*iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.key_type [*key_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.mapped_type [*mapped_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.reverse_iterator [*reverse_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.size_type [*size_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__data_map_proxy.value_type [*value_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__data_map_proxy.as [*as]]]
    [Get a value for the key as a specified type, with fallback. ]
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.begin [*begin]]]
    [Map iterators. ]
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.clear [*clear]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.count [*count]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.empty [*empty]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.end [*end]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.operator_map_type_& [*operator map_type &]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.operator_not_ [*operator!]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.operator_openbrace__closebrace_ [*operator[]]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.pick [*pick]]]
    [Get a value for the key, with fallback. ]
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.rbegin [*rbegin]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.rend [*rend]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.self_type [*self_type]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.set [*set]]]
    []
  ]
  
  [
    [[link cgi.reference.common__data_map_proxy.size [*size]]]
    []
  ]
  
]

This wraps the underlying data map and exposes a std::map-like interface for the different data maps.

It also includes an as<> member function which casts the found data into any type the user specifies. 



[endsect]



[section:self_type common::data_map_proxy::self_type]

[indexterm2 self_type..common::data_map_proxy] 

  self_type();



[endsect]



[section:set common::data_map_proxy::set]

[indexterm2 set..common::data_map_proxy] 

  void set(
      map_type & data);



[endsect]



[section:size common::data_map_proxy::size]

[indexterm2 size..common::data_map_proxy] 

  size_type size() const;



[endsect]



[section:size_type common::data_map_proxy::size_type]

[indexterm2 size_type..common::data_map_proxy] 

  typedef map_type::size_type size_type;




[endsect]



[section:value_type common::data_map_proxy::value_type]

[indexterm2 value_type..common::data_map_proxy] 

  typedef map_type::value_type value_type;




[endsect]



[endsect]


[section:common__error__cgi_errors common::error::cgi_errors]

[indexterm1 common::error::cgi_errors] 

  enum cgi_errors

[heading Values]
[variablelist

  [
    [client_closed]
    []
  ]

  [
    [duplicate_request]
    []
  ]

  [
    [accepting_on_an_open_request]
    []
  ]

  [
    [invalid_socket]
    []
  ]

  [
    [invalid_form_type]
    []
  ]

  [
    [broken_pipe]
    []
  ]

  [
    [bad_read]
    []
  ]

  [
    [bad_write]
    []
  ]

  [
    [client_not_open]
    []
  ]

  [
    [eof]
    []
  ]

  [
    [multipart_form_boundary_not_found]
    []
  ]

  [
    [multipart_meta_data_not_terminated]
    []
  ]

  [
    [no_boundary_marker]
    []
  ]

  [
    [already_closed]
    []
  ]

  [
    [max_post_exceeded]
    []
  ]

]



[endsect]


[section:common__form_parser common::form_parser]

A class for parsing POST data sent to a CGI process. 

  class form_parser


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__form_parser.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_parser.callback_type [*callback_type]]]
    [The callback functor to read more data. ]
  
  ]

  [

    [[link cgi.reference.common__form_parser__context [*context]]]
    [The context used for parsing. ]
  
  ]

  [

    [[link cgi.reference.common__form_parser.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_parser.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_parser.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_parser.buffer_string [*buffer_string]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_parser.form_parser [*form_parser]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_parser.move_to_start_of_first_part [*move_to_start_of_first_part]]]
    [Erase any front-cruft on the form data. ]
  ]
  
  [
    [[link cgi.reference.common__form_parser.parse [*parse]]]
    [Run the parser on the given `context`. ]
  ]
  
  [
    [[link cgi.reference.common__form_parser.parse_boundary_marker [*parse_boundary_marker]]]
    [Get the boundary marker from the CONTENT_TYPE header. ]
  ]
  
  [
    [[link cgi.reference.common__form_parser.parse_form_part [*parse_form_part]]]
    [Parse a single form part. ]
  ]
  
  [
    [[link cgi.reference.common__form_parser.parse_multipart_form [*parse_multipart_form]]]
    [Parse a multipart form. ]
  ]
  
  [
    [[link cgi.reference.common__form_parser.parse_url_encoded_form [*parse_url_encoded_form]]]
    [URL-encoded forms. ]
  ]
  
]

Construct this and then call `form\_parserparse` with an instance of form_parser::context (or compatible struct).

This is minimal and doesn't extract all meta-data yet, but is known to work on Windows XP with MSVC9.0 and Ubuntu linux with gcc 4.2.x and 4.3.x.

Valid Form Encodings > `application/x-www-form-urlencoded` > `multipart/form-data`

File uploads (ie. in `multipart/form-data` forms) are saved to disk. See the `BOOST\_CGI\_UPLOAD\_DIRECTORY` macro.

Should also work for HTTP POST data. 


[section:buffer_string common::form_parser::buffer_string]

[indexterm2 buffer_string..common::form_parser] 

  string_type buffer_string();



[endsect]



[section:buffer_type common::form_parser::buffer_type]

[indexterm2 buffer_type..common::form_parser] 

  typedef common::form_part::buffer_type buffer_type;




[endsect]



[section:callback_type common::form_parser::callback_type]

[indexterm2 callback_type..common::form_parser] The callback functor to read more data. 

  typedef boost::function< std::size_t(boost::system::error_code &) > callback_type;




[endsect]



[section:form_parser common::form_parser::form_parser]

[indexterm2 form_parser..common::form_parser] 

  form_parser();



[endsect]



[section:map_type common::form_parser::map_type]

[indexterm2 map_type..common::form_parser] 

  typedef common::map map_type;




[endsect]



[section:move_to_start_of_first_part common::form_parser::move_to_start_of_first_part]

[indexterm2 move_to_start_of_first_part..common::form_parser] Erase any front-cruft on the form data. 

  boost::system::error_code move_to_start_of_first_part(
      boost::system::error_code & ec);


In multipart forms, any characters that precede the first form boundary are ignored. This function erases those characters. 


[endsect]



[section:mutable_buffers_type common::form_parser::mutable_buffers_type]

[indexterm2 mutable_buffers_type..common::form_parser] 

  typedef boost::asio::mutable_buffers_1 mutable_buffers_type;




[endsect]



[section:parse common::form_parser::parse]

[indexterm2 parse..common::form_parser] Run the parser on the given `context`. 

  boost::system::error_code parse(
      context ctx,
      boost::system::error_code & ec);



[endsect]



[section:parse_boundary_marker common::form_parser::parse_boundary_marker]

[indexterm2 parse_boundary_marker..common::form_parser] Get the boundary marker from the CONTENT_TYPE header. 

  boost::system::error_code parse_boundary_marker(
      boost::system::error_code & ec);



[endsect]



[section:parse_form_part common::form_parser::parse_form_part]

[indexterm2 parse_form_part..common::form_parser] Parse a single form part. 

  boost::system::error_code parse_form_part(
      boost::system::error_code & ec);



[endsect]



[section:parse_multipart_form common::form_parser::parse_multipart_form]

[indexterm2 parse_multipart_form..common::form_parser] Parse a multipart form. 

  boost::system::error_code parse_multipart_form(
      boost::system::error_code & ec);


Parse forms where the content-type is "multipart/form-data". 


[endsect]



[section:parse_url_encoded_form common::form_parser::parse_url_encoded_form]

[indexterm2 parse_url_encoded_form..common::form_parser] URL-encoded forms. 

  boost::system::error_code parse_url_encoded_form(
      boost::system::error_code & ec);


Parse forms where the content-type is "application/www-url-encoded". 


[endsect]



[section:string_type common::form_parser::string_type]

[indexterm2 string_type..common::form_parser] 

  typedef common::form_part::string_type string_type;




[endsect]



[endsect]

[section:common__form_parser__context common::form_parser::context]

The context used for parsing. 

  struct context


[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_parser__context.boundary_marker [*boundary_marker]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.boundary_markers [*boundary_markers]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.buffer [*buffer]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.bytes_left [*bytes_left]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.callback [*callback]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.content_type [*content_type]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.data_map [*data_map]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.offset [*offset]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.pos [*pos]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.random_string [*random_string]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.stdin_parsed [*stdin_parsed]]]
    []
  ]

  [
    [[link cgi.reference.common__form_parser__context.uploads_map [*uploads_map]]]
    []
  ]

]


[section:boundary_marker common::form_parser::context::boundary_marker]

[indexterm2 boundary_marker..common::form_parser::context] 

  string_type boundary_marker;



[endsect]



[section:boundary_markers common::form_parser::context::boundary_markers]

[indexterm2 boundary_markers..common::form_parser::context] 

  std::list< string_type > boundary_markers;



[endsect]



[section:buffer common::form_parser::context::buffer]

[indexterm2 buffer..common::form_parser::context] 

  buffer_type & buffer;



[endsect]



[section:bytes_left common::form_parser::context::bytes_left]

[indexterm2 bytes_left..common::form_parser::context] 

  std::size_t & bytes_left;



[endsect]



[section:callback common::form_parser::context::callback]

[indexterm2 callback..common::form_parser::context] 

  const callback_type callback;



[endsect]



[section:content_type common::form_parser::context::content_type]

[indexterm2 content_type..common::form_parser::context] 

  string_type & content_type;



[endsect]



[section:data_map common::form_parser::context::data_map]

[indexterm2 data_map..common::form_parser::context] 

  common::post_map & data_map;



[endsect]



[section:offset common::form_parser::context::offset]

[indexterm2 offset..common::form_parser::context] 

  std::size_t offset;



[endsect]



[section:pos common::form_parser::context::pos]

[indexterm2 pos..common::form_parser::context] 

  buffer_type::iterator pos;



[endsect]



[section:random_string common::form_parser::context::random_string]

[indexterm2 random_string..common::form_parser::context] 

  string_type random_string;



[endsect]



[section:stdin_parsed common::form_parser::context::stdin_parsed]

[indexterm2 stdin_parsed..common::form_parser::context] 

  bool & stdin_parsed;



[endsect]



[section:uploads_map common::form_parser::context::uploads_map]

[indexterm2 uploads_map..common::form_parser::context] 

  common::upload_map & uploads_map;



[endsect]



[endsect]

[section:common__form_part common::form_part]



  struct form_part


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__form_part.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.iter_t [*iter_t]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.meta_data_map_type [*meta_data_map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.pair_t [*pair_t]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.range_type [*range_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__form_part.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_part.c_str [*c_str]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_part.empty [*empty]]]
    [TODO: Check that the uploaded file isn't empty too. ]
  ]
  
  [
    [[link cgi.reference.common__form_part.operator_const_char_type_* [*operator const char_type *]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_part.operator_std__basic_string_lt__T__gt_ [*operator std::basic_string< T >]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_part.operator_string_type [*operator string_type]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_part.operator_string_type_const_& [*operator string_type const &]]]
    []
  ]
  
  [
    [[link cgi.reference.common__form_part._form_part [*~form_part]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_part.boundary_marker_ [*boundary_marker_]]]
    [The boundary marker that's needed. ]
  ]

  [
    [[link cgi.reference.common__form_part.buffer_ [*buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.content_disposition [*content_disposition]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.content_type [*content_type]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.filename [*filename]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.meta_data_ [*meta_data_]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.name [*name]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.path [*path]]]
    []
  ]

  [
    [[link cgi.reference.common__form_part.value [*value]]]
    []
  ]

]

[heading Friends]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__form_part.operator_lt__lt_ [*operator<<]]]
    []
  ]
  
]


[section:boundary_marker_ common::form_part::boundary_marker_]

[indexterm2 boundary_marker_..common::form_part] The boundary marker that's needed. 

  string_type boundary_marker_;



[endsect]



[section:buffer_ common::form_part::buffer_]

[indexterm2 buffer_..common::form_part] 

  pair_t buffer_;



[endsect]



[section:buffer_type common::form_part::buffer_type]

[indexterm2 buffer_type..common::form_part] 

  typedef string_type buffer_type;




[endsect]



[section:c_str common::form_part::c_str]

[indexterm2 c_str..common::form_part] 

  const char_type * c_str() const;



[endsect]



[section:char_type common::form_part::char_type]

[indexterm2 char_type..common::form_part] 

  typedef char char_type;




[endsect]



[section:content_disposition common::form_part::content_disposition]

[indexterm2 content_disposition..common::form_part] 

  string_type content_disposition;



[endsect]



[section:content_type common::form_part::content_type]

[indexterm2 content_type..common::form_part] 

  string_type content_type;



[endsect]



[section:empty common::form_part::empty]

[indexterm2 empty..common::form_part] TODO: Check that the uploaded file isn't empty too. 

  bool empty() const;



[endsect]



[section:filename common::form_part::filename]

[indexterm2 filename..common::form_part] 

  boost::filesystem::path filename;



[endsect]



[section:iter_t common::form_part::iter_t]

[indexterm2 iter_t..common::form_part] 

  typedef buffer_type::iterator iter_t;




[endsect]



[section:meta_data_ common::form_part::meta_data_]

[indexterm2 meta_data_..common::form_part] 

  meta_data_map_type meta_data_;



[endsect]



[section:meta_data_map_type common::form_part::meta_data_map_type]

[indexterm2 meta_data_map_type..common::form_part] 

  typedef std::map< string_type, pair_t > meta_data_map_type;




[endsect]



[section:name common::form_part::name]

[indexterm2 name..common::form_part] 

  string_type name;



[endsect]



[section:operator_const_char_type_* common::form_part::operator const char_type *]

[indexterm2 operator const char_type *..common::form_part] 

  operator const char_type *() const;



[endsect]



[section:operator_std__basic_string_lt__T__gt_ common::form_part::operator std::basic_string< T >]

[indexterm2 operator std::basic_string< T >..common::form_part] 

  template<
      typename T >
  operator std::basic_string< T >();



[endsect]



[section:operator_string_type common::form_part::operator string_type]

[indexterm2 operator string_type..common::form_part] 

  operator string_type() const;



[endsect]



[section:operator_string_type_const_& common::form_part::operator string_type const &]

[indexterm2 operator string_type const &..common::form_part] 

  operator string_type const &() const;



[endsect]



[section:operator_lt__lt_ common::form_part::operator<<]

[indexterm2 operator<<..common::form_part] 

  friend std::ostream & operator<<(
      std::ostream & os,
      form_part const & part);



[endsect]



[section:pair_t common::form_part::pair_t]

[indexterm2 pair_t..common::form_part] 

  typedef std::pair< iter_t, iter_t > pair_t;




[endsect]



[section:path common::form_part::path]

[indexterm2 path..common::form_part] 

  boost::filesystem::path path;



[endsect]



[section:range_type common::form_part::range_type]

[indexterm2 range_type..common::form_part] 

  typedef boost::iterator_range< buffer_type::const_iterator > range_type;




[endsect]



[section:string_type common::form_part::string_type]

[indexterm2 string_type..common::form_part] 

  typedef std::basic_string< char_type > string_type;




[endsect]



[section:value common::form_part::value]

[indexterm2 value..common::form_part] 

  string_type value;



[endsect]



[section:_form_part common::form_part::~form_part]

[indexterm2 ~form_part..common::form_part] 

  ~form_part();



[endsect]



[endsect]

[section:common__has_hidden_io_service common::has_hidden_io_service]



  template<
      typename Protocol >
  struct has_hidden_io_service



[endsect]

[section:common__has_hidden_io_service_lt__tags__cgi__gt_ common::has_hidden_io_service< tags::cgi >]



  template<>
  struct has_hidden_io_service< tags::cgi >



[endsect]

[section:common__ichar_traits common::ichar_traits]



  template<
      typename CharT >
  struct ichar_traits


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__ichar_traits.compare [*compare]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.eq [*eq]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.find [*find]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.lt [*lt]]]
    []
  ]
  
  [
    [[link cgi.reference.common__ichar_traits.ne [*ne]]]
    []
  ]
  
]


[section:compare common::ichar_traits::compare]

[indexterm2 compare..common::ichar_traits] 

  static int compare(
      const char * str1,
      const char * str2,
      std::size_t num);



[endsect]



[section:eq common::ichar_traits::eq]

[indexterm2 eq..common::ichar_traits] 

  static bool eq(
      char c1,
      char c2);



[endsect]



[section:find common::ichar_traits::find]

[indexterm2 find..common::ichar_traits] 

  static const char * find(
      const char * str,
      int n,
      char a);



[endsect]



[section:lt common::ichar_traits::lt]

[indexterm2 lt..common::ichar_traits] 

  static bool lt(
      char c1,
      char c2);



[endsect]



[section:ne common::ichar_traits::ne]

[indexterm2 ne..common::ichar_traits] 

  static bool ne(
      char c1,
      char c2);



[endsect]



[endsect]

[section:common__io_service_provider common::io_service_provider]

Hold a set number of io_services and return them based on the Policy. 

  template<
      typename PoolingPolicy >
  class io_service_provider


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__io_service_provider.get_io_service [*get_io_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.io_service_provider [*io_service_provider]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.reset [*reset]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.run [*run]]]
    []
  ]
  
  [
    [[link cgi.reference.common__io_service_provider.stop [*stop]]]
    []
  ]
  
]

Contains six member functions: io\_service() - returns a reference to an io\_service stop() - stops all io\_services run() - runs all io\_services reset() - resets all io\_services

(strike) stop\_one() - stops one (running) io\_service (strike) run\_one() - runs one (not-yet-started/reset) io\_service

It can also be set up so that only required io\_services are run: each call to io\_service() can get an io\_service, call io\_service::run() on it and then return it. 


[section:get_io_service common::io_service_provider::get_io_service]

[indexterm2 get_io_service..common::io_service_provider] 

  ::BOOST_CGI_NAMESPACE::common::io_service & get_io_service();



[endsect]


[section:io_service_provider common::io_service_provider::io_service_provider]

[indexterm2 io_service_provider..common::io_service_provider] 

  ``[link cgi.reference.common__io_service_provider.io_service_provider.overload1 io_service_provider]``(
      int );

  ``[link cgi.reference.common__io_service_provider.io_service_provider.overload2 io_service_provider]``();


[section:overload1 common::io_service_provider::io_service_provider (1 of 2 overloads)]



  io_service_provider(
      int );



[endsect]



[section:overload2 common::io_service_provider::io_service_provider (2 of 2 overloads)]



  io_service_provider();



[endsect]


[endsect]


[section:reset common::io_service_provider::reset]

[indexterm2 reset..common::io_service_provider] 

  void reset();



[endsect]



[section:run common::io_service_provider::run]

[indexterm2 run..common::io_service_provider] 

  void run();



[endsect]



[section:stop common::io_service_provider::stop]

[indexterm2 stop..common::io_service_provider] 

  void stop();



[endsect]



[endsect]

[section:common__is_async common::is_async]



  template<
      typename Protocol >
  struct is_async



[endsect]

[section:common__is_async_lt__tags__cgi__gt_ common::is_async< tags::cgi >]



  template<>
  struct is_async< tags::cgi >



[endsect]

[section:common__map_read_error common::map_read_error]



  template<
      typename T >
  struct map_read_error


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__map_read_error.map_read_error [*map_read_error]]]
    []
  ]
  
]


[section:map_read_error common::map_read_error::map_read_error]

[indexterm2 map_read_error..common::map_read_error] 

  map_read_error();



[endsect]



[endsect]


[section:common__parse_options common::parse_options]

[indexterm1 common::parse_options] 

  enum parse_options

[heading Values]
[variablelist

  [
    [parse_none]
    []
  ]

  [
    [parse_env]
    []
  ]

  [
    [parse_get_only]
    []
  ]

  [
    [parse_get]
    []
  ]

  [
    [parse_post_only]
    []
  ]

  [
    [parse_post]
    []
  ]

  [
    [parse_form]
    []
  ]

  [
    [parse_form_only]
    []
  ]

  [
    [parse_cookie_only]
    []
  ]

  [
    [parse_cookie]
    []
  ]

  [
    [parse_cookies_only]
    []
  ]

  [
    [parse_cookies]
    []
  ]

  [
    [parse_all]
    []
  ]

]



[endsect]


[section:common__path_info common::path_info]



  struct path_info


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__path_info.const_iterator [*const_iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.iterator [*iterator]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.size_type [*size_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.value_type [*value_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__path_info.vector_type [*vector_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__path_info.begin [*begin]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.end [*end]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.extension [*extension]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.operator_value_type_& [*operator value_type &]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.operator_openbrace__closebrace_ [*operator[]]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.path_info [*path_info]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.stem [*stem]]]
    []
  ]
  
  [
    [[link cgi.reference.common__path_info.string [*string]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__path_info.parts [*parts]]]
    []
  ]

  [
    [[link cgi.reference.common__path_info.value [*value]]]
    []
  ]

]

[section:begin common::path_info::begin]

[indexterm2 begin..common::path_info] 

  iterator ``[link cgi.reference.common__path_info.begin.overload1 begin]``();

  const_iterator ``[link cgi.reference.common__path_info.begin.overload2 begin]``() const;


[section:overload1 common::path_info::begin (1 of 2 overloads)]



  iterator begin();



[endsect]



[section:overload2 common::path_info::begin (2 of 2 overloads)]



  const_iterator begin() const;



[endsect]


[endsect]


[section:const_iterator common::path_info::const_iterator]

[indexterm2 const_iterator..common::path_info] 

  typedef vector_type::const_iterator const_iterator;




[endsect]


[section:end common::path_info::end]

[indexterm2 end..common::path_info] 

  iterator ``[link cgi.reference.common__path_info.end.overload1 end]``();

  const_iterator ``[link cgi.reference.common__path_info.end.overload2 end]``() const;


[section:overload1 common::path_info::end (1 of 2 overloads)]



  iterator end();



[endsect]



[section:overload2 common::path_info::end (2 of 2 overloads)]



  const_iterator end() const;



[endsect]


[endsect]


[section:extension common::path_info::extension]

[indexterm2 extension..common::path_info] 

  string_type extension() const;



[endsect]



[section:iterator common::path_info::iterator]

[indexterm2 iterator..common::path_info] 

  typedef vector_type::iterator iterator;




[endsect]



[section:operator_value_type_& common::path_info::operator value_type &]

[indexterm2 operator value_type &..common::path_info] 

  operator value_type &();



[endsect]



[section:operator_openbrace__closebrace_ common::path_info::operator[]]

[indexterm2 operator[]..common::path_info] 

  value_type & operator[](
      int i);



[endsect]



[section:parts common::path_info::parts]

[indexterm2 parts..common::path_info] 

  vector_type parts;



[endsect]


[section:path_info common::path_info::path_info]

[indexterm2 path_info..common::path_info] 

  template<
      typename P >
  ``[link cgi.reference.common__path_info.path_info.overload1 path_info]``(
      basic_request< P > & request);

  ``[link cgi.reference.common__path_info.path_info.overload2 path_info]``(
      value_type const & str);


[section:overload1 common::path_info::path_info (1 of 2 overloads)]



  template<
      typename P >
  path_info(
      basic_request< P > & request);



[endsect]



[section:overload2 common::path_info::path_info (2 of 2 overloads)]



  path_info(
      value_type const & str);



[endsect]


[endsect]


[section:size_type common::path_info::size_type]

[indexterm2 size_type..common::path_info] 

  typedef string_type::size_type size_type;




[endsect]



[section:stem common::path_info::stem]

[indexterm2 stem..common::path_info] 

  string_type stem() const;



[endsect]



[section:string common::path_info::string]

[indexterm2 string..common::path_info] 

  value_type & string();



[endsect]



[section:string_type common::path_info::string_type]

[indexterm2 string_type..common::path_info] 

  typedef value_type string_type;




[endsect]



[section:value common::path_info::value]

[indexterm2 value..common::path_info] 

  value_type value;



[endsect]



[section:value_type common::path_info::value_type]

[indexterm2 value_type..common::path_info] 

  typedef std::string value_type;




[endsect]



[section:vector_type common::path_info::vector_type]

[indexterm2 vector_type..common::path_info] 

  typedef std::vector< value_type > vector_type;




[endsect]



[endsect]

[section:common__request_base common::request_base]

ABC that defines the common interface for basic_request<>s. 

  template<
      typename Protocol >
  class request_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base.base_type [*base_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.read_some [*read_some]]]
    [Read some data into the internal buffer. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base.status [*status]]]
    [Get the request status. ]
  ]
  
]

This class provides generic member functions that can be used by any request type. 


[section:base_type common::request_base::base_type]

[indexterm2 base_type..common::request_base] 

  typedef common::request_base< Protocol > base_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base.base_type [*base_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base.client [*client]]]
    [Return the connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base.is_open [*is_open]]]
    [Return if the request is still open. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.load_environment [*load_environment]]]
    [Load the base_environment into the current environment. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_cookie_vars [*parse_cookie_vars]]]
    [Read and parse the HTTP_COOKIE meta variable. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_get_vars [*parse_get_vars]]]
    [Read and parse the cgi GET meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.parse_post_vars [*parse_post_vars]]]
    [Read and parse the cgi POST meta variables. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.read_some [*read_some]]]
    [Read some data into the internal buffer. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.request_id [*request_id]]]
    [Get the request ID of a FastCGI request, or 1. ]
  ]
  
  [
    [[link cgi.reference.common__request_base.set_service [*set_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base.status [*status]]]
    [Get the request status. ]
  ]
  
]

This class provides generic member functions that can be used by any request type. 



[endsect]



[section:client common::request_base::client]

[indexterm2 client..common::request_base] Return the connection associated with the request. 

  template<
      typename ImplType >
  ImplType::client_type & client(
      ImplType & impl);



[endsect]



[section:destroy common::request_base::destroy]

[indexterm2 destroy..common::request_base] 

  template<
      typename ImplType >
  void destroy(
      ImplType & impl);



[endsect]



[section:is_open common::request_base::is_open]

[indexterm2 is_open..common::request_base] Return if the request is still open. 

  template<
      typename ImplType >
  bool is_open(
      ImplType & impl);



[endsect]



[section:load common::request_base::load]

[indexterm2 load..common::request_base] Synchronously read/parse the request meta-data. 

  template<
      typename ImplType >
  boost::system::error_code load(
      ImplType & impl,
      common::parse_options parse_opts,
      boost::system::error_code & ec);



[endsect]



[section:load_environment common::request_base::load_environment]

[indexterm2 load_environment..common::request_base] Load the base_environment into the current environment. 

  template<
      typename ImplType >
  void load_environment(
      ImplType & impl,
      char ** base_environment,
      bool is_command_line);


Parsed the base\_environment and add it to the current request's environment. This overwrites any environment variables with the existing key.

If `is\_command\_line` is true, then the first argument is skipped as this is the name of the program and ignored. Using it actually causes a crash on Windows (MSVC 9) anyway: I'm not exactly sure why. 


[endsect]



[section:parse_cookie_vars common::request_base::parse_cookie_vars]

[indexterm2 parse_cookie_vars..common::request_base] Read and parse the HTTP_COOKIE meta variable. 

  template<
      typename ImplType >
  boost::system::error_code parse_cookie_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_get_vars common::request_base::parse_get_vars]

[indexterm2 parse_get_vars..common::request_base] Read and parse the cgi GET meta variables. 

  template<
      typename ImplType >
  boost::system::error_code parse_get_vars(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:parse_post_vars common::request_base::parse_post_vars]

[indexterm2 parse_post_vars..common::request_base] Read and parse the cgi POST meta variables. 

  template<
      typename ImplType ,
      typename Callback >
  boost::system::error_code & parse_post_vars(
      ImplType & impl,
      Callback callback,
      boost::system::error_code & ec);



[endsect]


[section:read_some common::request_base::read_some]

[indexterm2 read_some..common::request_base] Read some data into the internal buffer. 

  template<
      typename ImplType >
  std::size_t ``[link cgi.reference.common__request_base.read_some.overload1 read_some]``(
      ImplType & impl,
      boost::system::error_code & ec);

  template<
      typename ImplType ,
      typename MutableBufferSequence >
  std::size_t ``[link cgi.reference.common__request_base.read_some.overload2 read_some]``(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);


[section:overload1 common::request_base::read_some (1 of 2 overloads)]

Read some data into the internal buffer. 

  template<
      typename ImplType >
  std::size_t read_some(
      ImplType & impl,
      boost::system::error_code & ec);



[endsect]



[section:overload2 common::request_base::read_some (2 of 2 overloads)]

Read some data from the client into the supplied buffer. 

  template<
      typename ImplType ,
      typename MutableBufferSequence >
  std::size_t read_some(
      ImplType & impl,
      const MutableBufferSequence & buf,
      boost::system::error_code & ec);



[endsect]


[endsect]


[section:request_id common::request_base::request_id]

[indexterm2 request_id..common::request_base] Get the request ID of a FastCGI request, or 1. 

  template<
      typename ImplType >
  boost::uint16_t const & request_id(
      ImplType & impl) const;



[endsect]



[section:set_service common::request_base::set_service]

[indexterm2 set_service..common::request_base] 

  template<
      typename ImplType >
  void set_service(
      ImplType & impl,
      typename ImplType::protocol_service_type & ps);



[endsect]


[section:status common::request_base::status]

[indexterm2 status..common::request_base] Get the request status. 

  template<
      typename ImplType >
  common::request_status ``[link cgi.reference.common__request_base.status.overload1 status]``(
      ImplType & impl) const;

  template<
      typename ImplType >
  void ``[link cgi.reference.common__request_base.status.overload2 status]``(
      ImplType & impl,
      common::request_status status);


[section:overload1 common::request_base::status (1 of 2 overloads)]

Get the request status. 

  template<
      typename ImplType >
  common::request_status status(
      ImplType & impl) const;



[endsect]



[section:overload2 common::request_base::status (2 of 2 overloads)]

Set the request status. 

  template<
      typename ImplType >
  void status(
      ImplType & impl,
      common::request_status status);



[endsect]


[endsect]


[endsect]

[section:common__request_base__callback_functor common::request_base::callback_functor]



  template<
      typename ImplType ,
      typename Service >
  struct callback_functor


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__callback_functor.callback_functor [*callback_functor]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__callback_functor.operator() [*operator()]]]
    []
  ]
  
]


[section:callback_functor common::request_base::callback_functor::callback_functor]

[indexterm2 callback_functor..common::request_base::callback_functor] 

  callback_functor(
      ImplType & impl,
      Service * service);



[endsect]



[section:operator() common::request_base::callback_functor::operator()]

[indexterm2 operator()..common::request_base::callback_functor] 

  std::size_t operator()(
      boost::system::error_code & ec);



[endsect]



[endsect]

[section:common__request_base__impl_base common::request_base::impl_base]



  struct impl_base


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.conn_ptr [*conn_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.form_parser_type [*form_parser_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.traits [*traits]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.var_map_type [*var_map_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__impl_base.http_status [*http_status]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.impl_base [*impl_base]]]
    [Construct. ]
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.prepare [*prepare]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.status [*status]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.stdin_parsed [*stdin_parsed]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__impl_base.all_done_ [*all_done_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.bytes_left_ [*bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.client_ [*client_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.form_parts_ [*form_parts_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.fp_ [*fp_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.post_buffer_ [*post_buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.request_status_ [*request_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.stdin_parsed_ [*stdin_parsed_]]]
    [Whether the post data has been parsed yet. ]
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.vars_ [*vars_]]]
    []
  ]

]


[section:all_done_ common::request_base::impl_base::all_done_]

[indexterm2 all_done_..common::request_base::impl_base] 

  bool all_done_;



[endsect]



[section:base_type common::request_base::impl_base::base_type]

[indexterm2 base_type..common::request_base::impl_base] 

  typedef impl_base base_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_base__impl_base.base_type [*base_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.conn_ptr [*conn_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.const_buffers_type [*const_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.form_parser_type [*form_parser_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.traits [*traits]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_base__impl_base.var_map_type [*var_map_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__impl_base.http_status [*http_status]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.impl_base [*impl_base]]]
    [Construct. ]
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.prepare [*prepare]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.status [*status]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_base__impl_base.stdin_parsed [*stdin_parsed]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_base__impl_base.all_done_ [*all_done_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.bytes_left_ [*bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.client_ [*client_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.form_parts_ [*form_parts_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.fp_ [*fp_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.http_status_ [*http_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.post_buffer_ [*post_buffer_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.request_status_ [*request_status_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.service_ [*service_]]]
    []
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.stdin_parsed_ [*stdin_parsed_]]]
    [Whether the post data has been parsed yet. ]
  ]

  [
    [[link cgi.reference.common__request_base__impl_base.vars_ [*vars_]]]
    []
  ]

]



[endsect]



[section:buffer_type common::request_base::impl_base::buffer_type]

[indexterm2 buffer_type..common::request_base::impl_base] 

  typedef traits::buffer_type buffer_type;




[endsect]



[section:bytes_left_ common::request_base::impl_base::bytes_left_]

[indexterm2 bytes_left_..common::request_base::impl_base] 

  std::size_t bytes_left_;



[endsect]



[section:char_type common::request_base::impl_base::char_type]

[indexterm2 char_type..common::request_base::impl_base] 

  typedef traits::char_type char_type;




[endsect]



[section:client_ common::request_base::impl_base::client_]

[indexterm2 client_..common::request_base::impl_base] 

  client_type client_;



[endsect]



[section:client_type common::request_base::impl_base::client_type]

[indexterm2 client_type..common::request_base::impl_base] 

  typedef traits::client_type client_type;




[endsect]



[section:conn_ptr common::request_base::impl_base::conn_ptr]

[indexterm2 conn_ptr..common::request_base::impl_base] 

  typedef connection_type::pointer conn_ptr;




[endsect]



[section:connection_type common::request_base::impl_base::connection_type]

[indexterm2 connection_type..common::request_base::impl_base] 

  typedef traits::connection_type connection_type;




[endsect]



[section:const_buffers_type common::request_base::impl_base::const_buffers_type]

[indexterm2 const_buffers_type..common::request_base::impl_base] 

  typedef traits::const_buffers_type const_buffers_type;




[endsect]



[section:form_parser_type common::request_base::impl_base::form_parser_type]

[indexterm2 form_parser_type..common::request_base::impl_base] 

  typedef traits::form_parser_type form_parser_type;




[endsect]



[section:form_parts_ common::request_base::impl_base::form_parts_]

[indexterm2 form_parts_..common::request_base::impl_base] 

  std::vector< common::form_part > form_parts_;



[endsect]



[section:fp_ common::request_base::impl_base::fp_]

[indexterm2 fp_..common::request_base::impl_base] 

  boost::scoped_ptr< form_parser_type > fp_;



[endsect]



[section:http_status common::request_base::impl_base::http_status]

[indexterm2 http_status..common::request_base::impl_base] 

  common::http::status_code & http_status();



[endsect]



[section:http_status_ common::request_base::impl_base::http_status_]

[indexterm2 http_status_..common::request_base::impl_base] 

  common::http::status_code http_status_;



[endsect]



[section:impl_base common::request_base::impl_base::impl_base]

[indexterm2 impl_base..common::request_base::impl_base] Construct. 

  impl_base();



[endsect]



[section:mutable_buffers_type common::request_base::impl_base::mutable_buffers_type]

[indexterm2 mutable_buffers_type..common::request_base::impl_base] 

  typedef traits::mutable_buffers_type mutable_buffers_type;




[endsect]



[section:post_buffer_ common::request_base::impl_base::post_buffer_]

[indexterm2 post_buffer_..common::request_base::impl_base] 

  buffer_type post_buffer_;



[endsect]



[section:prepare common::request_base::impl_base::prepare]

[indexterm2 prepare..common::request_base::impl_base] 

  mutable_buffers_type prepare(
      std::size_t size);



[endsect]



[section:protocol_service_type common::request_base::impl_base::protocol_service_type]

[indexterm2 protocol_service_type..common::request_base::impl_base] 

  typedef traits::protocol_service_type protocol_service_type;




[endsect]



[section:protocol_type common::request_base::impl_base::protocol_type]

[indexterm2 protocol_type..common::request_base::impl_base] 

  typedef Protocol protocol_type;




[endsect]



[section:request_status_ common::request_base::impl_base::request_status_]

[indexterm2 request_status_..common::request_base::impl_base] 

  common::request_status request_status_;



[endsect]



[section:request_type common::request_base::impl_base::request_type]

[indexterm2 request_type..common::request_base::impl_base] 

  typedef traits::request_type request_type;




[endsect]



[section:service_ common::request_base::impl_base::service_]

[indexterm2 service_..common::request_base::impl_base] 

  protocol_service_type * service_;



[endsect]


[section:status common::request_base::impl_base::status]

[indexterm2 status..common::request_base::impl_base] 

  common::request_status ``[link cgi.reference.common__request_base__impl_base.status.overload1 status]``() const;

  void ``[link cgi.reference.common__request_base__impl_base.status.overload2 status]``(
      common::request_status & st);


[section:overload1 common::request_base::impl_base::status (1 of 2 overloads)]



  common::request_status status() const;



[endsect]



[section:overload2 common::request_base::impl_base::status (2 of 2 overloads)]



  void status(
      common::request_status & st);



[endsect]


[endsect]


[section:stdin_parsed common::request_base::impl_base::stdin_parsed]

[indexterm2 stdin_parsed..common::request_base::impl_base] 

  bool stdin_parsed();



[endsect]



[section:stdin_parsed_ common::request_base::impl_base::stdin_parsed_]

[indexterm2 stdin_parsed_..common::request_base::impl_base] Whether the post data has been parsed yet. 

  bool stdin_parsed_;



[endsect]



[section:string_type common::request_base::impl_base::string_type]

[indexterm2 string_type..common::request_base::impl_base] 

  typedef traits::string_type string_type;




[endsect]



[section:traits common::request_base::impl_base::traits]

[indexterm2 traits..common::request_base::impl_base] 

  typedef detail::protocol_traits< Protocol > traits;




[endsect]



[section:var_map_type common::request_base::impl_base::var_map_type]

[indexterm2 var_map_type..common::request_base::impl_base] 

  typedef boost::fusion::vector< common::env_map, common::get_map, common::post_map, common::cookie_map, common::upload_map, common::session_map > var_map_type;



If you want to add a new data type to a request you need to: > Update this file (just below) > Update source_enums.hpp > Update map.hpp with a new map type > Add a member variable to basic\_request<> 


[endsect]



[section:vars_ common::request_base::impl_base::vars_]

[indexterm2 vars_..common::request_base::impl_base] 

  var_map_type vars_;



[endsect]



[endsect]

[section:common__request_service common::request_service]

The generic service class for basic_request<>s. 

  template<
      typename Protocol >
  class request_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__request_service.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_service.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__request_service.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__request_service.async_load [*async_load]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.load [*load]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.null [*null]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.request_service [*request_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.set_header [*set_header]]]
    []
  ]
  
  [
    [[link cgi.reference.common__request_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]

Note: If the protocol is an asynchronous protocol, which means it requires access to a boost::asio::io\_service instance, then this class becomes a model of the Service concept (**LINK**) and must only use the constructor which takes a ProtocolService (**LINK**). If the protocol isn't async then the class can be used without a ProtocolService. 


[section:async_load common::request_service::async_load]

[indexterm2 async_load..common::request_service] 

  template<
      typename Handler >
  void async_load(
      impl_type & impl,
      bool parse_stdin,
      Handler handler);



[endsect]



[section:construct common::request_service::construct]

[indexterm2 construct..common::request_service] 

  void construct(
      impl_type & impl);



[endsect]



[section:destroy common::request_service::destroy]

[indexterm2 destroy..common::request_service] 

  void destroy(
      impl_type & impl);



[endsect]



[section:impl_type common::request_service::impl_type]

[indexterm2 impl_type..common::request_service] 

  typedef service_impl_type::impl_type impl_type;




[endsect]



[section:implementation_type common::request_service::implementation_type]

[indexterm2 implementation_type..common::request_service] 

  typedef service_impl_type::implementation_type implementation_type;




[endsect]



[section:is_open common::request_service::is_open]

[indexterm2 is_open..common::request_service] 

  bool is_open(
      impl_type & impl);



[endsect]



[section:load common::request_service::load]

[indexterm2 load..common::request_service] 

  boost::system::error_code & load(
      impl_type & impl,
      bool parse_stdin,
      boost::system::error_code & ec);



[endsect]



[section:null common::request_service::null]

[indexterm2 null..common::request_service] 

  impl_type null() const;



[endsect]



[section:protocol_service_type common::request_service::protocol_service_type]

[indexterm2 protocol_service_type..common::request_service] 

  typedef common::basic_protocol_service< Protocol > protocol_service_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]



[section:protocol_type common::request_service::protocol_type]

[indexterm2 protocol_type..common::request_service] 

  typedef Protocol protocol_type;




[endsect]


[section:request_service common::request_service::request_service]

[indexterm2 request_service..common::request_service] 

  ``[link cgi.reference.common__request_service.request_service.overload1 request_service]``(
      ::BOOST_CGI_NAMESPACE::common::io_service & ios);

  ``[link cgi.reference.common__request_service.request_service.overload2 request_service]``(
      protocol_service_type & ps);


[section:overload1 common::request_service::request_service (1 of 2 overloads)]



  request_service(
      ::BOOST_CGI_NAMESPACE::common::io_service & ios);



[endsect]



[section:overload2 common::request_service::request_service (2 of 2 overloads)]



  request_service(
      protocol_service_type & ps);



[endsect]


[endsect]


[section:set_header common::request_service::set_header]

[indexterm2 set_header..common::request_service] 

  boost::system::error_code & set_header(
      impl_type & impl,
      const std::string & name,
      const std::string & value,
      boost::system::error_code & ec);



[endsect]



[section:shutdown_service common::request_service::shutdown_service]

[indexterm2 shutdown_service..common::request_service] 

  void shutdown_service();



[endsect]



[endsect]


[section:common__request_status common::request_status]

[indexterm1 common::request_status] 

  enum request_status

[heading Values]
[variablelist

  [
    [null]
    []
  ]

  [
    [unloaded]
    []
  ]

  [
    [activated]
    []
  ]

  [
    [accepted]
    []
  ]

  [
    [begin_request_found]
    []
  ]

  [
    [env_read]
    []
  ]

  [
    [get_read]
    []
  ]

  [
    [post_read]
    []
  ]

  [
    [cookies_read]
    []
  ]

  [
    [loaded]
    []
  ]

  [
    [ok]
    []
  ]

  [
    [aborted]
    []
  ]

  [
    [closed]
    []
  ]

]



[endsect]


[section:common__role__authorizer common::role::authorizer]



  struct authorizer



[endsect]

[section:common__role__filter common::role::filter]



  struct filter



[endsect]

[section:common__role__responder common::role::responder]



  struct responder



[endsect]


[section:common__role_type common::role_type]

[indexterm1 common::role_type] 

  enum role_type

[heading Values]
[variablelist

  [
    [none]
    []
  ]

  [
    [responder]
    []
  ]

  [
    [authorizer]
    []
  ]

  [
    [filter]
    []
  ]

]



[endsect]


[section:common__tags__async_stdio common::tags::async_stdio]



  struct async_stdio



[endsect]

[section:common__tags__cgi common::tags::cgi]



  struct cgi



[endsect]

[section:common__tags__fcgi common::tags::fcgi]



  struct fcgi



[endsect]

[section:common__tags__null common::tags::null]



  struct null



[endsect]

[section:common__tags__round_robin common::tags::round_robin]



  struct round_robin



[endsect]

[section:common__tags__scgi common::tags::scgi]



  struct scgi



[endsect]

[section:common__tags__service_pool common::tags::service_pool]



  struct service_pool



[endsect]

[section:common__tags__shareable_tcp_socket common::tags::shareable_tcp_socket]



  struct shareable_tcp_socket



[endsect]

[section:common__tags__single_service common::tags::single_service]



  struct single_service



[endsect]

[section:common__tags__stdio common::tags::stdio]



  struct stdio



[endsect]

[section:common__tags__tcp_socket common::tags::tcp_socket]



  struct tcp_socket



[endsect]

[section:connection_base connection_base]

Abstract Base Class for all connection types. 

  class connection_base


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.connection_base._connection_base [*~connection_base]]]
    []
  ]
  
]


[section:_connection_base connection_base::~connection_base]

[indexterm2 ~connection_base..connection_base] 

  ~connection_base();



[endsect]



[endsect]


[section: fcgi__acceptor]

Typedef for common usage (FCGI). 

  typedef ::BOOST_CGI_NAMESPACE::common::basic_request_acceptor< fcgi_request_acceptor_service<> > acceptor;




[endsect]



[section: fcgi__client]



  typedef common::basic_client< connections::shareable_tcp,::BOOST_CGI_NAMESPACE::common::tags::fcgi > client;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_client.connection_ptr [*connection_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.connection_type [*connection_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.header_buffer_type [*header_buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.io_service_type [*io_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.map_type [*map_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.mutable_buffers_type [*mutable_buffers_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_client.role_type [*role_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.async_read_some [*async_read_some]]]
    [Asynchronously read some data from the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.async_write_some [*async_write_some]]]
    [Asynchronously write some data to the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.basic_client [*basic_client]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.bytes_left [*bytes_left]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.close [*close]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.connection [*connection]]]
    [Get a shared_ptr of the connection associated with the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.construct [*construct]]]
    [Construct the client by claiming a request id. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.handle_write [*handle_write]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.is_open [*is_open]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.keep_connection [*keep_connection]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.prepare_buffer [*prepare_buffer]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.read_some [*read_some]]]
    [Read data into the supplied buffer. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.request_id [*request_id]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_client.set_connection [*set_connection]]]
    [Associate a connection with this client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.status [*status]]]
    [Get the status of the client. ]
  ]
  
  [
    [[link cgi.reference.common__basic_client.write_some [*write_some]]]
    [Write some data to the client. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_client.bytes_left_ [*bytes_left_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.header_ [*header_]]]
    [Buffer used to check the header of each packet. ]
  ]

  [
    [[link cgi.reference.common__basic_client.keep_connection_ [*keep_connection_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.outbuf_ [*outbuf_]]]
    [Output buffer. ]
  ]

  [
    [[link cgi.reference.common__basic_client.request_id_ [*request_id_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.role_ [*role_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.status_ [*status_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.total_sent_bytes_ [*total_sent_bytes_]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_client.total_sent_packets_ [*total_sent_packets_]]]
    []
  ]

]

A client is for two things: 1. To hold a full-duplex connection (or separate input and output connections). 2. To hold any protocol-specific data about the request. For now, this means the internal 'request number' associated by FastCGI with each request (ie. so incoming/outgoing packets can be wrapped with data noting what request it relates to). 3. Buffering. Not sure about how far this should go yet, but probably no further than minimal buffering. 4. Share a connection. Since a multiplexing connection is shared between multiple clients, the client should be responsible for taking possesion of the connection for a period of time (so it can write a complete packet). This idea could be taken quite far into genericity by making clients aware of how busy the connection is and size its output packets accordingly... But I'm not doing that. 



[endsect]



[section: fcgi__request]



  typedef common::basic_request< common::tags::fcgi > request;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_request.buffer_type [*buffer_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.client_type [*client_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.pointer [*pointer]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.protocol_service_type [*protocol_service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.service_type [*service_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.string_type [*string_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_request.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request.abort [*abort]]]
    [Abort a request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.auth_type [*auth_type]]]
    [Set the output for the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.basic_request [*basic_request]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.charset [*charset]]]
    [Get the charset from the CONTENT_TYPE header. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.clear [*clear]]]
    [Clear the data for the request, for reusing this object. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.client [*client]]]
    [Get the client connection associated with the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.close [*close]]]
    [Asynchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.content_length [*content_length]]]
    [Get the content length as a long. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.content_type [*content_type]]]
    [The content type of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.create [*create]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.gateway_interface [*gateway_interface]]]
    [The protocol used by the server to communicate to the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.hash [*hash]]]
    [Get a hashed interpretation of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.http_cookie [*http_cookie]]]
    [The cookies sent by the user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.http_from [*http_from]]]
    [The email of the user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.id [*id]]]
    [The id of this request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.is_open [*is_open]]]
    [Check if the request is still open (ie. not aborted or closed). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.load [*load]]]
    [Synchronously read/parse the request meta-data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.method [*method]]]
    [The method of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.path_info [*path_info]]]
    [Additional information, appendended to the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.path_translated [*path_translated]]]
    [The translated version of the path info. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.post_buffer [*post_buffer]]]
    [Get the buffer containing the POST data. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.query_string [*query_string]]]
    [The query string for the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.read_some [*read_some]]]
    [Read some data into the request, parsing if necessary. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.referer [*referer]]]
    [Get the web page the user came from. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.reject [*reject]]]
    [Reject the request with a '500 Internal Server Error' error. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_addr [*remote_addr]]]
    [The host address of the remote user. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_host [*remote_host]]]
    [The host name of the remote user's machine. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_ident [*remote_ident]]]
    [The user making the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.remote_user [*remote_user]]]
    [The userid of the person accessing the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.request_method [*request_method]]]
    [The method of the request (long-hand of `method()`). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.request_uri [*request_uri]]]
    [Get the URI of the request (long-hand of `uri()`). ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.role [*role]]]
    [The role that the request is playing. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_name [*script_name]]]
    [The name of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_uri [*script_uri]]]
    [The full URI of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.script_url [*script_url]]]
    [The URL of the script. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_name [*server_name]]]
    [Get the name of the server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_port [*server_port]]]
    [Get the port the calling server is listening on. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_protocol [*server_protocol]]]
    [Get the protocol being used by the calling server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.server_software [*server_software]]]
    [Get a string identifying the calling server. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.set_protocol_service [*set_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_request.status [*status]]]
    [Get / Set the status of a request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request.uri [*uri]]]
    [Get the URI of the request. ]
  ]
  
  [
    [[link cgi.reference.common__basic_request._basic_request [*~basic_request]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_request.cookies [*cookies]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.env [*env]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.form [*form]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.get [*get]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.post [*post]]]
    []
  ]

  [
    [[link cgi.reference.common__basic_request.uploads [*uploads]]]
    []
  ]

]

Note: By default, synchronous protocols (ie. cgi) auto-load AND parse STDIN,whereas async protocols don't.

Note: The alternative functions which take a boost::system::error\_code are the non-throwing versions. Instead of a boost::system::system\_error being thrown in case of an error, the passed error\_code will be set to the value of the error, s.t. if (error) evaluates to true.`

Note: This class isn't thread safe: carrying around a mutex-per-request seems prohibitively expensive. There could be functions which take a mutex as an argument and lock it. (Async calls could get messy if you need a protected request object). 



[endsect]



[section: fcgi__service]



  typedef common::basic_protocol_service< common::tags::fcgi > service;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.common__basic_protocol_service.ios_provider_type [*ios_provider_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.protocol_type [*protocol_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.queue_type [*queue_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_ptr [*request_ptr]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.request_type [*request_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.set_type [*set_type]]]
    []
  
  ]

  [

    [[link cgi.reference.common__basic_protocol_service.traits [*traits]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.common__basic_protocol_service.basic_protocol_service [*basic_protocol_service]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.dispatch [*dispatch]]]
    [Dispatch a handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.io_service [*io_service]]]
    [Return an available io_service from the IoServiceProvider. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.is_cgi [*is_cgi]]]
    []
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.post [*post]]]
    [Post the handler through an available io_service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.reset [*reset]]]
    [Reset all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.run [*run]]]
    [Run all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service.stop [*stop]]]
    [Stop all the io_services contained by this service. ]
  ]
  
  [
    [[link cgi.reference.common__basic_protocol_service._basic_protocol_service [*~basic_protocol_service]]]
    []
  ]
  
]

Holds the request queue and the connection queue. It is also a wrapper around asio::io\_service 



[endsect]


[section:request_acceptor_service request_acceptor_service]



  template<
      typename Protocol >
  class request_acceptor_service


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.request_acceptor_service.implementation_type [*implementation_type]]]
    []
  
  ]

  [

    [[link cgi.reference.request_acceptor_service.protocol_type [*protocol_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.request_acceptor_service.accept [*accept]]]
    [Accept a request. ]
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.async_accept [*async_accept]]]
    [Asynchronously accept a request. ]
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.construct [*construct]]]
    []
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.destroy [*destroy]]]
    []
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.request_acceptor_service [*request_acceptor_service]]]
    []
  ]
  
  [
    [[link cgi.reference.request_acceptor_service.shutdown_service [*shutdown_service]]]
    []
  ]
  
]


[section:accept request_acceptor_service::accept]

[indexterm2 accept..request_acceptor_service] Accept a request. 

  template<
      typename CommonGatewayRequest >
  boost::system::error_code & accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      boost::system::error_code & ec);


Check if there is a waiting request in the queue. If not, accept a connection, and associate it with the request. 


[endsect]



[section:async_accept request_acceptor_service::async_accept]

[indexterm2 async_accept..request_acceptor_service] Asynchronously accept a request. 

  template<
      typename CommonGatewayRequest ,
      typename Handler >
  void async_accept(
      implementation_type & impl,
      CommonGatewayRequest & request,
      Handler handler);



[endsect]



[section:construct request_acceptor_service::construct]

[indexterm2 construct..request_acceptor_service] 

  void construct(
      implementation_type & impl);



[endsect]



[section:destroy request_acceptor_service::destroy]

[indexterm2 destroy..request_acceptor_service] 

  void destroy(
      implementation_type & impl);



[endsect]



[section:implementation_type request_acceptor_service::implementation_type]

[indexterm2 implementation_type..request_acceptor_service] 

  typedef service_impl_type::impl_type implementation_type;




[endsect]



[section:protocol_type request_acceptor_service::protocol_type]

[indexterm2 protocol_type..request_acceptor_service] 

  typedef Protocol protocol_type;




[endsect]



[section:request_acceptor_service request_acceptor_service::request_acceptor_service]

[indexterm2 request_acceptor_service..request_acceptor_service] 

  request_acceptor_service(
      basic_protocol_service< protocol_type > & s);



[endsect]



[section:shutdown_service request_acceptor_service::shutdown_service]

[indexterm2 shutdown_service..request_acceptor_service] 

  void shutdown_service();



[endsect]



[endsect]

[section:stencils__dictionary stencils::dictionary]

A lightweight wrapper around a ctemplate::TemplateDictionary. 

  class dictionary


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.stencils__dictionary.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__dictionary.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__dictionary.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__dictionary.add [*add]]]
    [Add a section into the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.dictionary [*dictionary]]]
    []
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.include [*include]]]
    [Include a file into the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.set [*set]]]
    [Set the varible `name` to `value` in the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.show [*show]]]
    [Show a section. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__dictionary.impl [*impl]]]
    []
  ]

]


[section:add stencils::dictionary::add]

[indexterm2 add..stencils::dictionary] Add a section into the stencil. 

  dictionary add(
      section const & sec);



[endsect]


[section:dictionary stencils::dictionary::dictionary]

[indexterm2 dictionary..stencils::dictionary] 

  ``[link cgi.reference.stencils__dictionary.dictionary.overload1 dictionary]``();

  ``[link cgi.reference.stencils__dictionary.dictionary.overload2 dictionary]``(
      impl_type * impl);


[section:overload1 stencils::dictionary::dictionary (1 of 2 overloads)]



  dictionary();



[endsect]



[section:overload2 stencils::dictionary::dictionary (2 of 2 overloads)]



  dictionary(
      impl_type * impl);



[endsect]


[endsect]


[section:impl stencils::dictionary::impl]

[indexterm2 impl..stencils::dictionary] 

  impl_type * impl;



[endsect]



[section:impl_type stencils::dictionary::impl_type]

[indexterm2 impl_type..stencils::dictionary] 

  typedef ctemplate::TemplateDictionary impl_type;




[endsect]


[section:include stencils::dictionary::include]

[indexterm2 include..stencils::dictionary] Include a file into the stencil. 

  dictionary ``[link cgi.reference.stencils__dictionary.include.overload1 include]``(
      string_type const & section_name,
      string_type const & filename);

  dictionary ``[link cgi.reference.stencils__dictionary.include.overload2 include]``(
      section const & sec);


[section:overload1 stencils::dictionary::include (1 of 2 overloads)]

Include a file into the stencil. 

  dictionary include(
      string_type const & section_name,
      string_type const & filename);



[heading Return Value]
      
dictionary The returned sub-dictionary is used to set fields in an included stencil.

[heading Parameters]
    

[variablelist
  
[[section_name][The name of the section, and of the marker in the stencil. Add {{>section\_name}} into the stencil to include a file's contents. ]]

[[filename][The name of the file to include. This must be set. ]]

]



[endsect]



[section:overload2 stencils::dictionary::include (2 of 2 overloads)]

Include a file into the stencil. 

  dictionary include(
      section const & sec);



[heading Return Value]
      
dictionary The returned sub-dictionary is used to set fields in an included stencil.

[heading Parameters]
    

[variablelist
  
[[sec][The section to include. Be sure to set *both* the section name and filename first. ]]

]



[endsect]


[endsect]


[section:self_type stencils::dictionary::self_type]

[indexterm2 self_type..stencils::dictionary] 

  typedef dictionary self_type;


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.stencils__dictionary.impl_type [*impl_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__dictionary.self_type [*self_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__dictionary.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__dictionary.add [*add]]]
    [Add a section into the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.dictionary [*dictionary]]]
    []
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.include [*include]]]
    [Include a file into the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.set [*set]]]
    [Set the varible `name` to `value` in the stencil. ]
  ]
  
  [
    [[link cgi.reference.stencils__dictionary.show [*show]]]
    [Show a section. ]
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__dictionary.impl [*impl]]]
    []
  ]

]



[endsect]


[section:set stencils::dictionary::set]

[indexterm2 set..stencils::dictionary] Set the varible `name` to `value` in the stencil. 

  template<
      typename T >
  self_type & ``[link cgi.reference.stencils__dictionary.set.overload1 set]``(
      string_type const & name,
      T value);

  template<
      typename T >
  self_type & ``[link cgi.reference.stencils__dictionary.set.overload2 set]``(
      string_type const & name,
      T value,
      section const & sec);

  template<>
  dictionary & ``[link cgi.reference.stencils__dictionary.set.overload3 set]``(
      string_type const & name,
      string_type const & value);

  template<>
  dictionary & ``[link cgi.reference.stencils__dictionary.set.overload4 set]``(
      string_type const & name,
      string_type const & value,
      section const & sec);


[section:overload1 stencils::dictionary::set (1 of 4 overloads)]

Set the varible `name` to `value` in the stencil. 

  template<
      typename T >
  self_type & set(
      string_type const & name,
      T value);



[heading Parameters]
    

[variablelist
  
[[name][The name of the variable. Use {{name}} in the stencil. ]]

[[value][The value, can be any type that is supported by boost::lexical\_cast. See the docs for lexical\_cast: http://www.boost.org/libs/lexical\_cast]]

]



[endsect]



[section:overload2 stencils::dictionary::set (2 of 4 overloads)]

Set a variable and show a section in one go. 

  template<
      typename T >
  self_type & set(
      string_type const & name,
      T value,
      section const & sec);



[endsect]



[section:overload3 stencils::dictionary::set (3 of 4 overloads)]

Set the varible `name` to `value` in the stencil. 

  template<>
  dictionary & set(
      string_type const & name,
      string_type const & value);



[endsect]



[section:overload4 stencils::dictionary::set (4 of 4 overloads)]

Set a variable and show a section in one go. 

  template<>
  dictionary & set(
      string_type const & name,
      string_type const & value,
      section const & sec);



[endsect]


[endsect]


[section:show stencils::dictionary::show]

[indexterm2 show..stencils::dictionary] Show a section. 

  self_type & show(
      section const & sec);



[endsect]



[section:string_type stencils::dictionary::string_type]

[indexterm2 string_type..stencils::dictionary] 

  typedef std::string string_type;




[endsect]



[endsect]

[section:stencils__include_error stencils::include_error]



  class include_error


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__include_error.include_error [*include_error]]]
    []
  ]
  
]


[section:include_error stencils::include_error::include_error]

[indexterm2 include_error..stencils::include_error] 

  template<
      typename Str >
  include_error(
      Str const & section_name,
      Str const & filename);



[endsect]



[endsect]

[section:stencils__section stencils::section]

A class used to represent a section in the stencil. 

  class section


[heading Types]
[table
  [[Name][Description]]

  [

    [[link cgi.reference.stencils__section.char_type [*char_type]]]
    []
  
  ]

  [

    [[link cgi.reference.stencils__section.string_type [*string_type]]]
    []
  
  ]

]

[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__section.section [*section]]]
    []
  ]
  
]

[heading Data Members]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__section.filename [*filename]]]
    []
  ]

  [
    [[link cgi.reference.stencils__section.name [*name]]]
    []
  ]

]


[section:char_type stencils::section::char_type]

[indexterm2 char_type..stencils::section] 

  typedef char char_type;




[endsect]



[section:filename stencils::section::filename]

[indexterm2 filename..stencils::section] 

  string_type filename;



[endsect]



[section:name stencils::section::name]

[indexterm2 name..stencils::section] 

  string_type name;



[endsect]


[section:section stencils::section::section]

[indexterm2 section..stencils::section] 

  ``[link cgi.reference.stencils__section.section.overload1 section]``();

  ``[link cgi.reference.stencils__section.section.overload2 section]``(
      const char_type * name,
      const char_type * filename = "");

  ``[link cgi.reference.stencils__section.section.overload3 section]``(
      string_type const & name,
      string_type const & filename = "");


[section:overload1 stencils::section::section (1 of 3 overloads)]



  section();



[endsect]



[section:overload2 stencils::section::section (2 of 3 overloads)]



  section(
      const char_type * name,
      const char_type * filename = "");



[endsect]



[section:overload3 stencils::section::section (3 of 3 overloads)]



  section(
      string_type const & name,
      string_type const & filename = "");



[endsect]


[endsect]


[section:string_type stencils::section::string_type]

[indexterm2 string_type..stencils::section] 

  typedef std::basic_string< char_type > string_type;




[endsect]



[endsect]

[section:stencils__template_error stencils::template_error]



  class template_error


[heading Member Functions]
[table
  [[Name][Description]]

  [
    [[link cgi.reference.stencils__template_error.template_error [*template_error]]]
    []
  ]
  
]


[section:template_error stencils::template_error::template_error]

[indexterm2 template_error..stencils::template_error] 

  template<
      typename Str >
  template_error(
      Str const & filename);



[endsect]



[endsect]

[endsect]